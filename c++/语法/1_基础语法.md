|目录|
|--|
|[1. 条件语句](#1-条件语句)|
|[2. 循环语句](#2-循环语句)|
|[3. lambda表达式](#3-lambda表达式)|


# 1 条件语句

**if条件**
```c++
if (notify == 1) {
    std::cout << data <<" notify" << std::endl;
}else if (notify == 2){
    std::cout << data <<" notify" << std::endl;
}else {
    std::cout << data <<" notify" << std::endl;
}
```

**switch条件语句**：
```c++
int notify = 1;
switch (notify) {
    case 1: {
        std::cout << data << std::endl;
    } // 可加大括号，也可不加
    case 2:
        std::cout << data << std::endl;
        break; // 退出switch语句，如果没有则会执行下一个case的代码，即使case不满足条件
    default: // 当以上case都不满足或者没有签名执行的case中没有break语句时，会执行default的代码
        std::cout << data << std::endl;
}
```

# 2 循环语句

c++中的循环语句包含如下5种：

```c++
// while循环
int i = 0;
while (i < 5) {
    std::cout << "while i = " << i << std::endl;
    if (++i > 4) {
        break; // 退出循环
    }
}

// do...while循环
do {
    std::cout << "do-while i = " << i << std::endl;
    ++i;
} while (i < 5);


// for循环
for (int i = 0; i < 5; ++i) {
    std::cout << "for i = " << i << std::endl;
}

// for循环（）每次循环x为v每个元素的拷贝，对x的修改不会影响v中元素的值
std::vector<int> v{1, 2, 3, 4, 5};
for (int x : v) {
    x++;
    std::cout << "range-for x = " << x << std::endl;
}

// 引用版本（避免拷贝， 每次循环x都是v中元素的引用，对x的修改会影响v中元素的值）
for (int& x : v) {
    x *= 2;
}

loop:
if (i >= 5)
    goto end;
std::cout << "goto loop i = " << i << std::endl;
++i;
goto loop;
end:
```

# 3 Lambda表达式

**无参数、无返回值**:

```c++
[] {
    std::cout<<"lambda 表达式"<<std::endl;
}();
```

**自动返回类型**

```c++
auto result = [] {
    return "自动返回类型";
}(); // result类型将是const char*
std::cout << result << std::endl;
```

**显示返回类型**:
```c++
std::string result = []-> std::string {
    return "显示返回类型";
}();
std::cout << result << std::endl;
```

**值捕获**:

```c++
int a = 1;
[a] {
    // lambda表达式中的值捕获是const修饰的，不能修改
    std::cout << a << std::endl;
}();
```

**引用捕获**：

```c++
int a = 1;
[&a] {
    a++; // 引用捕获后，修改lambda表达式中捕获的参数会影响原本的参数值
    std::cout << a << std::endl;
}();
std::cout << a << std::endl;
```

**捕获多个变量**：

```c++
std::string result;
int a = 1;
[result, &a] {
    std::cout << a << std::endl;
}();
```

**捕获所有外部变量**:

```c++
// 值捕获所有外部变量
std::string result;
int a = 1;
[=] {
    std::cout << a << std::endl;
    std::cout << result << std::endl;
}();
```

```c++
// 引用捕获所有外部变量
std::string result;
int a = 1;
[&] {
    std::cout << a << std::endl;
    std::cout << result << std::endl;
}();
```

**默认捕获 + 显式指定**：

```c++
std::string result;
int a = 1;
[=, &a， r] {
    // a使用引用捕获，其他变量使用值捕获
    a++;
    std::cout << a << std::endl;
}();

[&, a] {
    // a使用值捕获，其他变量使用引用捕获
    a++;
    std::cout << a << std::endl;
}();
```

**初始化捕获（C++14）**：

```c++
std::string result("原始值");
[result = "初始化捕获"] { // 这里的初始化不会修改result的原始值
    std::cout << result << std::endl;
}();
std::cout << result << std::endl;
```

**move捕获**：

```c++
 std::unique_ptr<int> p = std::make_unique<int>(1);
[ptr = std::move(p)] {
    std::cout << *ptr << std::endl;
}();
if (p == nullptr){
    std::cout << "p为空" << std::endl; // 将执行这条语句
}else {
    std::cout << "p不为空" << std::endl;
}
```

**捕获this**：

```c++
class A {
public:
    void f() {
        [this] {
            std::cout << value;
        }();
    }
private:
    int value = 10;
};

A aa;
aa.f();
```

# 4 结构体

## 4.1 结构体的定义

**空结构体**:

```c++
struct Person{};
printf("%llu\n", sizeof(Person)); // 输出为1
```

**含成员变量的结构体**：

```c++
struct Person {
    std::string name;
    int age;
};
```

**在定义结构体的同时声明变量**:

```c++
struct Person {
    std::string name;
    int age{};
}p1, p2, p3;
```

**匿名结构体**:

```c++
struct {
    float f;
}n1, n2;
```

**定义结构体的方法**：

```c++
struct Person{
    std::string name;
    int age;

    // 定义构造函数
    Person(std::string name, int age): name(std::move(name)), age(age) {}

    // 定义构造函数
    Person() {
        this->name = "";
        this->age = 0;
    }

    // 定义析构函数
    ~Person() {
        // 释放资源
        age = 0;
    }
};
```

## 4.2 结构体的初始化

**默认初始化**：
```c++
struct Person {
    std::string name = "John";
    int age = 5;
};
Person p; // 默认初始化
```

**聚合初始化**：
```c++
struct Person {
    std::string name;
    int age;
};
Person p{"dd", 343}; // 聚合初始化
```

**指定成员初始化**
```c++
struct Person {
    std::string name;
    int age;
};
Person p{.age = 9, .name = "jake"}; // 指定成员初始化(C++20)
```

## 4.3 结构体内存对齐

**对齐填充**：
```c++
struct Packed {
    char a;
    int b;
};
printf("%lld\n", sizeof(Packed)); // 输出8
```

**强制紧凑布局**:
```c++
#pragma pack(push, 1)
struct Packed {
    char a;
    int b;
};
#pragma pack(pop)
printf("%lld\n", sizeof(Packed)); // 输出5
```

## 4.4 结构体的访问权限
结构体成员变量/方法的访问权限有`public`、`private`、`protected`

```c++
struct Person {
public:
    std::string name =  "John";
private:
    int age = 5;
protected:
    float weight = 0;
};
```

对于`public`权限的成员变量/方法，可以公开访问。
对于`private`权限的成员变量/方法，只能在结构体内部访问，例如结构体内部定义的方法
对于`protected`权限的成员变量/方法，只能在结构体内部访问，例如结构体内部定义的方法
```c++
struct Person {
public: // 公开权限
    std::string name =  "John";
private: // 私有权限
    int age = 5;
protected: // 受保护权限
    float weight = 0;
};
Person p;
p.name = "可读可写" // public的成员变量可在外部直接访问
printf("%d\n", p.age); // 错误，私有权限不能直接从外部访问
printf("%f\n", p.weight); // 错误，受保护权限不能直接从外部访问
```

对于在结构体内声明了友元函数的，声明的函数可以访问结构体的私有和受保护成员变量和方法。
```c++
struct Person {
    friend void Show(Person p); // 声明友元函数，该签名的函数可以访问私有和受保护的成员变量、方法
public:
    std::string name =  "John";
private:
    int age = 5;
    int getAge() {
        return age;
    }
protected:
    float weight = 0;
};

void Show(Person p) {
    printf("Name: %s, age=%d, weight=%f\n", p.name.c_str(), p.age, p.weight);
    p.getAge(); // 友元函数可访问私有/受保护方法
}
```

## 4.5 结构体运算符重载

```c++
struct Person {
    std::string name =  "John";
    int age = 5;
    // 重载比较运算符，`==  !=  <  <=  >  >=`这些运算符无需手写了
    auto operator<=>(const Person &other) const = default;
    
    // 自定义+运算符
    Person operator+(const Person &other) const {
        return Person{name, age + other.age};
    }
};

Person p;
Person p2{.name="John", .age=  3};
std::printf("%d\n", p > p2); // 先比较name，如果一致再比较age，输出1
std::printf("%d\n", (p + p2).age); // 输出8
```

## 4.6 结构体继承

结构体支持继承，并且可以继承多个

```c++
struct Base {
    int id;
};

// 继承Base
struct Person: Base{
    std::string name =  "John";
    int age = 5;
};
```

**虚函数**
```c++
struct  Base {
    int id = 0;
    virtual int getId() = 0; // 定义的虚函数
};

struct Person: Base{
    std::string name =  "John";
    int age = 5;
    int getId() { // Base的继承者需要实现Base的虚函数才能实例化
        return id;
    }
};
```

>定义了虚函数的结构体/类不能实例化

**多态**

```c++
struct Base {
    int id = 0;
    virtual void Show() = 0; // 虚函数
};

struct Person: Base{
    std::string name =  "John";
    int age = 5;
    void Show() {
        printf("I'm a person\n");
    }
};

struct Book: Base {
    std::string name;
    void Show() {
        printf("I'm a book\n");
    }
};


int main() {
    Base* b = new Book;
    b->Show(); // I'm a book
    b = new Person;
    b->Show(); // I'm a person
}
```

## 4.7 模板化结构体

```c++
template<typename T>
struct Box {
    T value;
};

int main() {
    Box<int> intBox;
    Box<std::string> strBox;
}
```

## 4.8 constexpr修饰

```c++
struct Point {
    int x;
    constexpr Point(int v) : x(v) {}
};
、
int main() {
    Point p(3); // 可再编译器执行，当作一个常量
}
```

## 5 线程

**常用的启动线程的方式**：
```c++
#include <thread>
#include <iostream>

void worker() {
    std::cout << "hello from thread\n";
}

int main() {
    std::thread t(worker); // 创建并启动线程
    t.join();              // 等待线程结束
    // t.detach();           // 不等待线程,后台运行，无法再控制
}
```

**传参**

如果给线程传的参数是引用类型的参数，必须使用std::ref
```c++
void f(int& x) {
    x++;
}

int a = 10;
std::thread t(f, std::ref(a)); // 引用类型必须使用std::ref
t.join();
```

**成员函数作为线程入口**：
```c++
struct Worker {
    void run(int x) {
        std::cout << x << "\n";
    }
};

Worker w;
std::thread t(&Worker::run, &w, 42);
t.join();
```

**RAII 封装**：

以下是线程RALL封装的示例
```c++
class ThreadGuard {
    std::thread& t;
public:
    explicit ThreadGuard(std::thread& t_) : t(t_) {}
    ~ThreadGuard() {
        if (t.joinable()) {
            t.join();
        }
    }
};
```

它解决的问题是如果函数返回前没有 join / detach，程序会直接 std::terminate。而通过以上封装后，无论函数如何退出（正常 return / 异常），都保证线程被 join。

```c++
#include <thread>
#include <iostream>

class ThreadGuard {
    std::thread& t;
public:
    // std::thread不可拷贝，因此只能用引用的方法传参
    explicit ThreadGuard(std::thread& t_) : t(t_) {}
    ~ThreadGuard() {
        if (t.joinable()) {
            t.join();
        }
    }

    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
};

void worker() {
    std::cout << "hello from thread\n";
}

int main() {
    std::thread t(worker); // 创建线程变量
    ThreadGuard g(t);
}
```