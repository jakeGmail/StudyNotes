|目录|
|--|
|[1. 条件语句](#1-条件语句)|
|[2. 循环语句](#2-循环语句)|
|[3. lambda表达式](#3-lambda表达式)|


# 1 条件语句

**if条件**
```c++
if (notify == 1) {
    std::cout << data <<" notify" << std::endl;
}else if (notify == 2){
    std::cout << data <<" notify" << std::endl;
}else {
    std::cout << data <<" notify" << std::endl;
}
```

**switch条件语句**：
```c++
int notify = 1;
switch (notify) {
    case 1: {
        std::cout << data << std::endl;
    } // 可加大括号，也可不加
    case 2:
        std::cout << data << std::endl;
        break; // 退出switch语句，如果没有则会执行下一个case的代码，即使case不满足条件
    default: // 当以上case都不满足或者没有签名执行的case中没有break语句时，会执行default的代码
        std::cout << data << std::endl;
}
```

# 2 循环语句

c++中的循环语句包含如下5种：

```c++
// while循环
int i = 0;
while (i < 5) {
    std::cout << "while i = " << i << std::endl;
    if (++i > 4) {
        break; // 退出循环
    }
}

// do...while循环
do {
    std::cout << "do-while i = " << i << std::endl;
    ++i;
} while (i < 5);


// for循环
for (int i = 0; i < 5; ++i) {
    std::cout << "for i = " << i << std::endl;
}

// for循环（）每次循环x为v每个元素的拷贝，对x的修改不会影响v中元素的值
std::vector<int> v{1, 2, 3, 4, 5};
for (int x : v) {
    x++;
    std::cout << "range-for x = " << x << std::endl;
}

// 引用版本（避免拷贝， 每次循环x都是v中元素的引用，对x的修改会影响v中元素的值）
for (int& x : v) {
    x *= 2;
}

loop:
if (i >= 5)
    goto end;
std::cout << "goto loop i = " << i << std::endl;
++i;
goto loop;
end:
```

# 3 Lambda表达式

**无参数、无返回值**:

```c++
[] {
    std::cout<<"lambda 表达式"<<std::endl;
}();
```

**自动返回类型**

```c++
auto result = [] {
    return "自动返回类型";
}(); // result类型将是const char*
std::cout << result << std::endl;
```

**显示返回类型**:
```c++
std::string result = []-> std::string {
    return "显示返回类型";
}();
std::cout << result << std::endl;
```

**值捕获**:

```c++
int a = 1;
[a] {
    // lambda表达式中的值捕获是const修饰的，不能修改
    std::cout << a << std::endl;
}();
```

**引用捕获**：

```c++
int a = 1;
[&a] {
    a++; // 引用捕获后，修改lambda表达式中捕获的参数会影响原本的参数值
    std::cout << a << std::endl;
}();
std::cout << a << std::endl;
```

**捕获多个变量**：

```c++
std::string result;
int a = 1;
[result, &a] {
    std::cout << a << std::endl;
}();
```

**捕获所有外部变量**:

```c++
// 值捕获所有外部变量
std::string result;
int a = 1;
[=] {
    std::cout << a << std::endl;
    std::cout << result << std::endl;
}();
```

```c++
// 引用捕获所有外部变量
std::string result;
int a = 1;
[&] {
    std::cout << a << std::endl;
    std::cout << result << std::endl;
}();
```

**默认捕获 + 显式指定**：

```c++
std::string result;
int a = 1;
[=, &a， r] {
    // a使用引用捕获，其他变量使用值捕获
    a++;
    std::cout << a << std::endl;
}();

[&, a] {
    // a使用值捕获，其他变量使用引用捕获
    a++;
    std::cout << a << std::endl;
}();
```

**初始化捕获（C++14）**：

```c++
std::string result("原始值");
[result = "初始化捕获"] { // 这里的初始化不会修改result的原始值
    std::cout << result << std::endl;
}();
std::cout << result << std::endl;
```

**move捕获**：

```c++
 std::unique_ptr<int> p = std::make_unique<int>(1);
[ptr = std::move(p)] {
    std::cout << *ptr << std::endl;
}();
if (p == nullptr){
    std::cout << "p为空" << std::endl; // 将执行这条语句
}else {
    std::cout << "p不为空" << std::endl;
}
```

**捕获this**：

```c++
class A {
public:
    void f() {
        [this] {
            std::cout << value;
        }();
    }
private:
    int value = 10;
};

A aa;
aa.f();
```

# 4 结构体

## 4.1 结构体的定义

**空结构体**:

```c++
struct Person{};
printf("%llu\n", sizeof(Person)); // 输出为1
```

**含成员变量的结构体**：

```c++
struct Person {
    std::string name;
    int age;
};
```

**在定义结构体的同时声明变量**:

```c++
struct Person {
    std::string name;
    int age{};
}p1, p2, p3;
```

**匿名结构体**:

```c++
struct {
    float f;
}n1, n2;
```

**定义结构体的方法**：

```c++
struct Person{
    std::string name;
    int age;

    // 定义构造函数
    Person(std::string name, int age): name(std::move(name)), age(age) {}

    // 定义构造函数
    Person() {
        this->name = "";
        this->age = 0;
    }

    // 定义析构函数
    ~Person() {
        // 释放资源
        age = 0;
    }
};
```

## 4.2 结构体的初始化

**默认初始化**：
```c++
struct Person {
    std::string name = "John";
    int age = 5;
};
Person p; // 默认初始化
```

**聚合初始化**：
```c++
struct Person {
    std::string name;
    int age;
};
Person p{"dd", 343}; // 聚合初始化
```

**指定成员初始化**
```c++
struct Person {
    std::string name;
    int age;
};
Person p{.age = 9, .name = "jake"}; // 指定成员初始化(C++20)
```

## 4.3 结构体内存对齐

**对齐填充**：
```c++
struct Packed {
    char a;
    int b;
};
printf("%lld\n", sizeof(Packed)); // 输出8
```

**强制紧凑布局**:
```c++
#pragma pack(push, 1)
struct Packed {
    char a;
    int b;
};
#pragma pack(pop)
printf("%lld\n", sizeof(Packed)); // 输出5
```

## 4.4 结构体的访问权限
结构体成员变量/方法的访问权限有`public`、`private`、`protected`

```c++
struct Person {
public:
    std::string name =  "John";
private:
    int age = 5;
protected:
    float weight = 0;
};
```

对于`public`权限的成员变量/方法，可以公开访问。
对于`private`权限的成员变量/方法，只能在结构体内部访问，例如结构体内部定义的方法
对于`protected`权限的成员变量/方法，只能在结构体内部访问，例如结构体内部定义的方法
```c++
struct Person {
public: // 公开权限
    std::string name =  "John";
private: // 私有权限
    int age = 5;
protected: // 受保护权限
    float weight = 0;
};
Person p;
p.name = "可读可写" // public的成员变量可在外部直接访问
printf("%d\n", p.age); // 错误，私有权限不能直接从外部访问
printf("%f\n", p.weight); // 错误，受保护权限不能直接从外部访问
```

对于在结构体内声明了友元函数的，声明的函数可以访问结构体的私有和受保护成员变量和方法。
```c++
struct Person {
    friend void Show(Person p); // 声明友元函数，该签名的函数可以访问私有和受保护的成员变量、方法
public:
    std::string name =  "John";
private:
    int age = 5;
    int getAge() {
        return age;
    }
protected:
    float weight = 0;
};

void Show(Person p) {
    printf("Name: %s, age=%d, weight=%f\n", p.name.c_str(), p.age, p.weight);
    p.getAge(); // 友元函数可访问私有/受保护方法
}
```

## 4.5 结构体运算符重载

```c++
struct Person {
    std::string name =  "John";
    int age = 5;
    // 重载比较运算符，`==  !=  <  <=  >  >=`这些运算符无需手写了
    auto operator<=>(const Person &other) const = default;
    
    // 自定义+运算符
    Person operator+(const Person &other) const {
        return Person{name, age + other.age};
    }
};

Person p;
Person p2{.name="John", .age=  3};
std::printf("%d\n", p > p2); // 先比较name，如果一致再比较age，输出1
std::printf("%d\n", (p + p2).age); // 输出8
```

## 4.6 结构体继承

结构体支持继承，并且可以继承多个

```c++
struct Base {
    int id;
};

// 继承Base
struct Person: Base{
    std::string name =  "John";
    int age = 5;
};
```

**虚函数**
```c++
struct  Base {
    int id = 0;
    virtual int getId() = 0; // 定义的虚函数
};

struct Person: Base{
    std::string name =  "John";
    int age = 5;
    int getId() { // Base的继承者需要实现Base的虚函数才能实例化
        return id;
    }
};
```

>定义了虚函数的结构体/类不能实例化

**多态**

```c++
struct Base {
    int id = 0;
    virtual void Show() = 0; // 虚函数
};

struct Person: Base{
    std::string name =  "John";
    int age = 5;
    void Show() {
        printf("I'm a person\n");
    }
};

struct Book: Base {
    std::string name;
    void Show() {
        printf("I'm a book\n");
    }
};


int main() {
    Base* b = new Book;
    b->Show(); // I'm a book
    b = new Person;
    b->Show(); // I'm a person
}
```

## 4.7 模板化结构体

```c++
template<typename T>
struct Box {
    T value;
};

int main() {
    Box<int> intBox;
    Box<std::string> strBox;
}
```

## 4.8 constexpr修饰

```c++
struct Point {
    int x;
    constexpr Point(int v) : x(v) {}
};
、
int main() {
    Point p(3); // 可再编译器执行，当作一个常量
}
```

## 5 线程

**常用的启动线程的方式**：
```c++
#include <thread>
#include <iostream>

void worker() {
    std::cout << "hello from thread\n";
}

int main() {
    std::thread t(worker); // 创建并启动线程
    t.join();              // 等待线程结束
    // t.detach();           // 不等待线程,后台运行，无法再控制
}
```

**传参**

如果给线程传的参数是引用类型的参数，必须使用std::ref
```c++
void f(int& x) {
    x++;
}

int a = 10;
std::thread t(f, std::ref(a)); // 引用类型必须使用std::ref
t.join();
```

**成员函数作为线程入口**：
```c++
struct Worker {
    void run(int x) {
        std::cout << x << "\n";
    }
};

Worker w;
std::thread t(&Worker::run, &w, 42);
t.join();
```

**RAII 封装**：

以下是线程RALL封装的示例
```c++
class ThreadGuard {
    std::thread& t;
public:
    explicit ThreadGuard(std::thread& t_) : t(t_) {}
    ~ThreadGuard() {
        if (t.joinable()) {
            t.join();
        }
    }
};
```

它解决的问题是如果函数返回前没有 join / detach，程序会直接 std::terminate。而通过以上封装后，无论函数如何退出（正常 return / 异常），都保证线程被 join。

```c++
#include <thread>
#include <iostream>

class ThreadGuard {
    std::thread& t;
public:
    // std::thread不可拷贝，因此只能用引用的方法传参
    explicit ThreadGuard(std::thread& t_) : t(t_) {}
    ~ThreadGuard() {
        if (t.joinable()) {
            t.join();
        }
    }

    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
};

void worker() {
    std::cout << "hello from thread\n";
}

int main() {
    std::thread t(worker); // 创建线程变量
    ThreadGuard g(t);
}
```

**线程池**：

C++20推荐使用标准线程池
```c++
void worker() {
    std::cout << "hello from thread\n";
}

std::jthread t(worker); // 标准线程池，析构时会自动调用join
```

## 6 协程

### 6.1 协程的定义
c++的协程与go的协程差异很大，go的协程是异步执行， c++的协程执行还是用的当前线程的执行，是同步执行，只是你可以手动控制协程函数的挂起与继续执行。如果需要在C++上实现协程异步执行，需要额外调度器或线程池实现。

<font color=#eb8eee>**协程的定义**</font>：只要一个函数返回一个结构体，并且结构体内部定义了promise_type结构体，这个函数就可能被编译器转换成协程。

工程级别定义协程
```c++
#include <chrono>
#include <coroutine>
#include <iostream>
#include <cassert>
#include <thread>

struct Task {;

    /*协程的“控制面板”, 定义协程的行为*/
    struct promise_type {
        /*当协程被创建时，编译器调用这个函数,用它来构造 foo() 的返回值*/
        Task get_return_object() {
            return Task(std::coroutine_handle<promise_type>::from_promise(*this));
        }

        //协程创建后，不立刻挂起，直接开始执行。
        //std::suspend_never initial_suspend() noexcept { return {}; }

        //协程不会立刻执行，直到调用.h.resume()，（工程推荐用这个： 如果立即执行协程还没注册到调度器就开始跑，race / 生命周期混乱）
        std::suspend_always initial_suspend() noexcept { return {}; }


        // 协程结束时，不再挂起，直接销毁。
        //std::suspend_never final_suspend() noexcept { return {}; }

        // 协程结束时仍然挂起，等待显式 destroy. (工程推荐用这个：如果协程结束立即销毁，你还持有 coroutine_handle，极易形成 悬空 handle（UB）)
        std::suspend_always final_suspend() noexcept { return {}; }

        void return_void() {}

        // 协程中抛异常的处理方式
        void unhandled_exception() {
            exception = std::current_exception();
        }
        std::exception_ptr exception{nullptr};
    };

    std::coroutine_handle<promise_type> h{nullptr}; // 协程句柄

    explicit Task(std::coroutine_handle<promise_type> handle)
       : h(handle) {}

    Task(Task&& other) noexcept : h(other.h) {
        other.h = nullptr;
    }

    Task& operator=(Task&& other) noexcept {
        if (this != &other) {
            if (h) h.destroy();
            h = other.h;
            other.h = nullptr;
        }
        return *this;
    }

    // 禁止拷贝（非常重要）
    Task(const Task&) = delete;
    Task& operator=(const Task&) = delete;

    ~Task() {
        if (h) {
            h.destroy();
        }
    }

    bool done() const {
        return !h || h.done();
    }

    void resume() {
        assert(h && !h.done() && "resuming a finished coroutine");

        h.resume();

        if (h.promise().exception) {
            std::rethrow_exception(h.promise().exception);
        }
    }
};

Task foo(int a) {
    std::cout << "hello " << a << "\n";
    co_await std::suspend_always{}; // 真正挂起
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "world\n";
}

int main() {
    Task t = foo(42);      // 协程创建，但不执行
    std::cout << "Before resume\n";
    t.resume();             // 输出: hello 42
    t.resume();             // 输出: world
    std::cout << "After resume\n";
}

```

### 6.2 co_await操作符

`co_await` 是 C++20 协程的核心操作符，用于 **挂起协程、等待某个 awaitable 对象完成，然后恢复协程**。它和 Go 的 `await` / `yield` 有点类似，但需要理解 C++ 协程的执行模型。下面我给你系统讲解。
