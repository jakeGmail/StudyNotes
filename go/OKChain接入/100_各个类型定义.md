[toc]
# 1 keys.Info类型
keys.Info用于描述密钥信息，其定义如下
```go
type Info interface {
	// Human-readable type for key listing
	GetType() KeyType
	// Name of the key
	GetName() string
	// Public key
	GetPubKey() crypto.PubKey
	// Address
	GetAddress() types.AccAddress
	// Bip44 Path
	GetPath() (*hd.BIP44Params, error)
	// Algo
	GetAlgo() SigningAlgo
}
```
**方法**
- <font color=green>GetType</font>: 获取密钥类型。KeyType是uint类型的别名，其类型有4种
```go
const (
	TypeLocal   KeyType = 0
	TypeLedger  KeyType = 1
	TypeOffline KeyType = 2
	TypeMulti   KeyType = 3
)
```
这几个类型对应的字符串为：
```go
var keyTypes = map[KeyType]string{
	TypeLocal:   "local",
	TypeLedger:  "ledger",
	TypeOffline: "offline",
	TypeMulti:   "multi",
}
```
在使用fmt打印KeyType类型时，可以直接打印出对应的字符串，这是因为KeyType类型实现了`String()`接口

- <font color=green>GetName</font>: 获取密钥的名称，根创建时传入的名称一致。通常用于u识别该密钥
- <font color=green>GetPubKey</font>: 获取公钥，用于加密和验证操作。
公钥的定义为
```go
type PubKey interface {
	Address() Address // []byte，16进制地址
	Bytes() []byte
	VerifyBytes(msg []byte, sig []byte) bool
	Equals(PubKey) bool
}
```

- <font color=green>GetAddress</font>: 返回一个types.AccAddress类型的地址（Bech32的账户地址），用于识别和处理交易等操作. 用简单的话讲，Info.GetAddress() 方法会从公钥中获取和返回对应的地址。地址是基于公钥通过一定的编码和哈希算法得到的。这个地址通常与区块链账户关联，充当了区块链网络中账户的唯一标识。所以，Info.GetAddress()方法用于从公钥获取账户地址。

```go
// 获取公钥的地址，也是账户地址(OKBC钱包地址)
keyInfo.GetPubKey().Address().String()
```

- <font color=green>GetPath</font>: 返回一个*hd.BIP44Params类型的路径，用于确定该密钥的位置
- <font color=green>GetAlgo</font>: 返回SigningAlgo，表示用于该密钥的签名算法。

# 2 types.Account类型
```go
type Account interface {
	Copy() Account
	GetAddress() AccAddress
	SetAddress(AccAddress) error
	GetPubKey() crypto.PubKey
	SetPubKey(crypto.PubKey) error
	GetAccountNumber() uint64
	SetAccountNumber(uint64) error
	GetSequence() uint64
	SetSequence(uint64) error
	GetCoins() Coins
	SetCoins(Coins) error
	SpendableCoins(blockTime time.Time) Coins
	String() string
}
```
**方法**:
- <font color=red>Copy</font>: 创建并返回一个当前账户的副本。
- <font color=red>GetAddress</font>: 获取账户的地址[types.AccAddress](#21-typesaccaddress类型), 这个地址就是钱包的账户地址(OKBC钱包地址)
- <font color=red>SetAddress</font>: 设置账户的地址（AccAddress）
- <font color=red>GetPubKey</font>: 获取账户的公钥（crypto.PubKey）
- <font color=red>SetPubKey</font>: 设置账户的公钥（crypto.PubKey）
- <font color=red>GetAccountNumber</font>: 获取账户的账户号码（uint64）。账户号是在区块链上唯一标识一个账户的数字或字符串。每个账户都有一个独特的账户号，用于区分不同的账户。账户号通常是通过一种哈希算法从账户的公钥生成的，因此账户可以使用其账户号进行标识，而不需要直接暴露公钥。
- <font color=red>SetAccountNumber</font>: 设置账户的账户号码（uint64）。
- <font color=red>GetSequence</font>: 获取账户的序列号（uint64）。账户序列是一个整数值，用于对账户的交易进行排序和防止重放攻击。每当一个账户生成一笔交易时，其账户序列号都会自动递增。这意味着账户序列号可以用来确保交易按照正确的顺序被处理，而且相同序列号的交易不会被重复处理。
- <font color=red>SetSequence</font>: 设置账户的序列号（uint64）。
- <font color=red>GetCoins</font>: 获取账户的代币（Coins）,详见[Coins类型](#3-coins类型)
- <font color=red>SetCoins</font>: 设置账户的代币（Coins）。
- <font color=red>SpendableCoins</font>: 获取可用于消费的代币（Coins）。
- <font color=red>String</font>: 将账户信息转换为字符串形式

## 2.1 types.AccAddress类型
```go
// 账户地址, sdk.AccAddress、sdk.ValAddress也是这个类型
type AccAddress []byte
```
**成员方法**:
|AccAddress的成员方法|描述|
|-------------------|----|
|func (aa AccAddress) <font color=blue>String()</font> string|返回账户地址，以Bech32的格式。示例："ex1rp7fjqtswsfjac4karreqnphxjgk8kckzueq9k"|
|func (aa AccAddress) <font color=blue>Bytes()</font> []byte|以byte切片的形式返回账户地址（10进制，如果把每一个byte转化为16进制，那么这个地址前加上0x就是账户的地址）。示例：[24 124 153 1 112 116 19 46 226 182 232 199 144 76 55 52 145 99 219 22]|
|func (aa AccAddress) <font color=blue>Marshal()</font> ([]byte, error)|将地址编码为一组字节，以便于在网络上传输或存储。|
|func (aa *AccAddress) <font color=blue>Unmarshal(data []byte)</font> error|从编码后的字节数据中解码并获取一个地址。|
|func (aa AccAddress) <font color=blue>MarshalJSON()</font> ([]byte, error)|使用Bech32地址转化为Json格式, 得到的[]byte转化为字符串为<font color=red>"ex1-----------"</font>|

**注意**：
1. 如果直接打印AccAddress类型，会得到钱包上的账户地址。
```fmt.Println("acc addr=", account.GetAddress())```
`187C99017074132EE2B6E8C7904C37349163DB16`（16进制）

# 3 Coins类型
```go
type SysCoin = DecCoin
type Coins = DecCoins
type DecCoins []DecCoin
type DecCoin struct {
	Denom  string `json:"denom"`
	// Dec底层是*big.Int
	Amount Dec    `json:"amount"`
}
```
Coins类型是DecCoin的切片，这是因为在多币种的区块链网络中，一个账户可能拥有多种不同的币种，如 OKT、USDT 等。它们会被作为DecCoin存储在Coins字段中。当你调用GetCoins()方法时，你将得到这个账户拥有的各种币种及其数量的列表。
<font color=blue>以下是Coins类型中的方法：</font>
- [判断Coins下是否全部币种都是正值---isallpositive](#31-isallpositive方法)
- [获取Coins下币种的个数---Len](#32-len方法)
- [向Coins中添加币种--Add](#33-向coins中添加币种)
- [对所有DecCoin乘以一个系数--MulDec](#34-对所有deccoin乘以一个系数)
- [以字符串形式输出代币数量和种类信息](#35-输出coins信息)

## 3.1 **IsAllPositive方法**：
```go
// 如果至少有一枚DecCoin并且所有货币都是正值返回true，否则返回false
func (coins DecCoins) IsAllPositive() bool
```

**DecCoin为负数的原因**
理论上说，`types.DecCoin`结构体中的`Amount`（表示金额）可以被设置为一个负数。这可能发生在某些特定场景下，例如有时需要表示或处理一笔交易的负面金额或净损失。注意，这种用法在实际操作中可能并不常见，因为通常情况下，余额和交易金额应该是非负的。

然而，在某些特定的计算和算法中，允许`Amount`取负值可能会带来一些便利。例如，当我们需要计算两个`DecCoin`金额之间的差额时，允许负值的存在可以使得计算更简单。

请注意，在实际应用中，根据应用场景和业务逻辑的要求，你可能需要添加一些验证和限制机制，以确保在不允许负值的场景下，`Amount`是非负的。

**示例代码**
```go
package main

import (
	"fmt"
	"github.com/okex/exchain-go-sdk/types"
)

func main() {
	// 创建一个DecCoins对象，其中包含两个DecCoin，它们的金额都是正的。
	positiveCoins := types.DecCoins{
		{Denom: "BTC", Amount: types.NewDecWithPrec(100, 0)},
		{Denom: "ETH", Amount: types.NewDecWithPrec(50, 0)},
	}

	// 使用函数IsAllPositive()检查DecCoins对象中的金额是否都是正的。
	if positiveCoins.IsAllPositive() {
		fmt.Println("All coins in the DecCoins object are positive.")
	} else {
		fmt.Println("Some or all of the coins in the DecCoins object are not positive.")
	}

	// 创建一个DecCoins对象，其中包含两个DecCoin，一个是正的，一个是负的。
	negativeCoins := types.DecCoins{
		{Denom: "BTC", Amount: types.NewDecWithPrec(100, 0)},
		{Denom: "ETH", Amount: types.NewDecWithPrec(-50, 0)},
	}

	// 使用函数IsAllPositive()检查DecCoins对象中的金额是否都是正的。
	if negativeCoins.IsAllPositive() {
		fmt.Println("All coins in the DecCoins object are positive.")
	} else {
		fmt.Println("Some or all of the coins in the DecCoins object are not positive.")
	}
}
```

## 3.2 **Len方法**：
```go
func (coins DecCoins) Len() int
```
**作用**：
获取DecCoins下的DecCoin的个数。

## 3.3 向Coins中添加币种
```go
func (coins DecCoins) Add(coinsB ...DecCoin) DecCoins
```
**作用**：
向当前DecCoins中添加新的DecCoin，对于币种相同的DecCoin，合并其数值，币种不同的添加到当前DecCoins中。

**使用示例**
```go
add_coin := types.DecCoin{
	Denom: "bt", Amount: types.NewDecWithPrec(123, 2),
}
// 输出coin number2=1
fmt.Println("coin number1=", coin.Len())
coin = coin.Add(add_coin)
// 输出 coin number2=2
fmt.Println("coin number2=", coin.Len())

// coins info: 1.230000000000000000bt,14251.843020781362962966okt
fmt.Println("coins info:", coins.String())
```

## 3.4 对所有DecCoin乘以一个系数
```
func (coins DecCoins) MulDec(d Dec) DecCoins
```

**功能描述**：
MulDec 方法接受一个 sdk.Dec 类型参数（代表小数值），它的作用是将 types.Coins 列表中的每一个货币的数量乘以给定的小数值。

在 MulDec 方法中，会遍历 types.Coins 列表中的每一个货币，将当前货币的数量乘以给定的小数值，再将得到的结果四舍五入为整数，并将结果作为新的货币数量。最终，MulDec 方法返回一个新的 types.Coins 列表，其中每个货币的数量都有更新。

MulDec 方法用于调整或计算货币列表中每种货币经过某个系数运算后的新数量。例如，它在计算奖励或分配的资金时，会根据需要扩大或缩小每种货币的数量。

**代码示例**:
```go
// before multi coin= 1.230000000000000000bt,14251.843020781362962966okt
fmt.Println("before multi coin=", coins.String())

// 将每种货币的数量乘以2.5
coins = coins.MulDec(types.NewDecWithPrec(25, 1))

// after multi coin= 3.075000000000000000bt,35629.607551953407407415okt
fmt.Println("after multi coin=", coins.String())
```

## 3.5 输出Coins信息
```go
func (coins DecCoins) String() string
```

**功能**:
获取Coins中包含的全部币种和数量信息，以字符串的形式输出。例如：
`1.230000000000000000bt,14251.843020781362962966okt`
**代码示例**:
```go
// 获取账户信息
accInfo, err := client.Auth().QueryAccount(info.GetAddress().String())
if err != nil {
	log.Fatal(err)
}

// 获取币种列表
coins := accInfo.GetCoins()

// 打印币种和数量信息
// 1.230000000000000000bt,14251.843020781362962966okt
fmt.Println("coins info:", coins.String())
```

## 3.6 sdk.Dec类型
sdk.Dec类型表示小数，其底层是用*big.Int进行存储，但前面18位表示整数部分，18位后面表示小数部分. 使用sdk.Dec.String()方法可以获取到小数的字符串。


# 4 DecCoin类型
```go
type DecCoin struct {
	Denom  string `json:"denom"`
	Amount Dec    `json:"amount"`
}
```
**成员变量**:
- <font color=red>Denom</font>: 币种名称。例如，"BTC"表示比特币，"ETH"表示以太币， "okt"表示OK币。
- <font color=red>Amount</font>: 代表某种币种的数值。它以十进制形式存储金额，并且在进行数值操作时会进行溢出检查。这有助于避免在数值计算时出现错误。

例如，一个DecCoin可能像下面这样表示：
```go
coin := types.DecCoin{
	Denom:  "BTC",
	Amount: types.NewDecWithPrec(100, 0),
}
```
在这个例子中，Denom是"BTC"，表示这是一个比特币，而Amount是100，表示这是100个比特币。
其中`types.NewDecWithPrec`是一个函数，在`github.com/okex/exchain-go-sdk`库的`types`模块中定义。这个函数用于创建一个新的`Dec`(Decimal，即十进制值)对象。

它有两个参数:
1. `i`: 这是一个int64参数，表示该十进制数的整数部分。
2. `prec`: 这是一个int8参数，表示该十进制数值小数点后的位数。

例如，`types.NewDecWithPrec(100, 1)`生成的是一个值为10的`Dec`，因为`100`是整数部分，而`1`告诉我们将整数部分向右移动一位以获取正确的小数值。同理，`types.NewDecWithPrec(12345, 3)`生成的是一个值为12.345的`Dec`。

总体来说，这个函数是一个方便的方式来构造一个新的`Dec`值，特别是当你有一个原始的整数值以及你知道小数点应该在哪里的时候。


# 5 ClientConfig类型
```go
type ClientConfig struct {
	NodeURI       string
	ChainID       string
	ChainIDBigInt *big.Int
	BroadcastMode string
	Gas           uint64
	GasAdjustment float64
	Fees          sdk.DecCoins
	GasPrices     sdk.DecCoins
}
```
- <font color=red>NodeURI</font>: 存放要连接的区块链节点的URI，也就是该节点的网络地址
- <font color=red>ChainID</font>:  区块链网络的唯一标识。每个区块链网络都有一个唯一的 ChainID ，不同的网络其 ChainID 是不同的。
- <font color=red>ChainIDBigInt</font>: 提供一种用大数来表示 ChainID 的方式，可能在某些需要大数运算的场景下会用到。
- <font color=red>BroadcastMode</font>:指示如何广播交易。常见的模式有同步（sync）、异步（async）和阻塞（block）。
- <font color=red>Gas</font>: 用来设置交易所需的 gas 上限。Gas 通常用来计算执行交易所需的计算资源
- <font color=red>GasAdjustment</font>: 这是一个调整因子，用于调整预估的Gas值以减少因误算所结果带来的失败。如果该值大于1则预估值会增加；如果小于1则预估值会减少。
- <font color=red>Fees</font>: 独立的费用字段，用户可以指定一种或多种币作为交易费用。单位为小数形式的 coin
- <font color=red>GasPrices</font>:指定 gas 的单价，用于计算交易费用。当 Fees 较高时可以使交易更快完成。

# 5 types.TransferUnit类型
```go
type (
	TransferUnit = tokentypes.TransferUnit
	TokenResp    = tokentypes.TokenResp
)

type TransferUnit struct {
	To    sdk.AccAddress `json:"to"`  // []byte类型
	Coins sdk.SysCoins   `json:"coins"`
}

type SysCoins = DecCoins
```

# 6 types.TokenResp类型
```go
// 定义了一个令牌的各个属性
type TokenResp struct {
	Description         string         `json:"description" v2:"description"`
	Symbol              string         `json:"symbol" v2:"symbol"`
	OriginalSymbol      string         `json:"original_symbol" v2:"original_symbol"`
	WholeName           string         `json:"whole_name" v2:"whole_name"`
	OriginalTotalSupply sdk.Dec        `json:"original_total_supply" v2:"original_total_supply"`
	Type                int            `json:"type"`
	Owner               sdk.AccAddress `json:"owner" v2:"owner"`
	Mintable            bool           `json:"mintable" v2:"mintable"`
	TotalSupply         sdk.Dec        `json:"total_supply" v2:"total_supply"`
}
```
- <font color=red>Description</font>:令牌的描述信息。
- <font color=red>Symbol</font>:令牌的简写符号（如BTC，ETH等）
- <font color=red>OriginalSymbol</font>:原始的令牌符号。
- <font color=red>WholeName</font>:令牌的完整名称。
- <font color=red>OriginalTotalSupply</font>:原始的令牌总供应量。类型是*big.Int
- <font color=red>Type</font>:一个整数，代表令牌的类型。
- <font color=red>Owner</font>:表示令牌的拥有者。
- <font color=red>Mintable</font>:布尔值，表示是否可以增发此令牌
- <font color=red>TotalSupply</font>:当前的令牌总供应量。

请注意，字段后面的json和v2标签是用来在进行JSON序列化和反序列化时用作字段的键的。例如，当TokenResp结构体被序列化为JSON时，Symbol字段将变成"symbol"，当从JSON反序列化时，也会寻找"symbol"来填充Symbol字段。

# 7 sdk.TxResponse类型
```go
type TxResponse struct {
	Height    int64           `json:"height"`
	TxHash    string          `json:"txhash"`
	Codespace string          `json:"codespace,omitempty"`
	Code      uint32          `json:"code,omitempty"`
	Data      string          `json:"data,omitempty"`
	RawLog    string          `json:"raw_log,omitempty"`
	Logs      ABCIMessageLogs `json:"logs,omitempty"`
	Info      string          `json:"info,omitempty"`
	GasWanted int64           `json:"gas_wanted,omitempty"`
	GasUsed   int64           `json:"gas_used,omitempty"`
	Tx        Tx              `json:"tx,omitempty"`
	Timestamp string          `json:"timestamp,omitempty"`
}
```
**成员变量含义**:
|成员名称|描述|
|-------|----|
|Height|代表交易所在区块的高度。|
|TxHash|交易唯一的哈希值|
|Codespace|错误代码空间，当交易成功时为空。如果交易失败，它将包含错误来源的描述。|
|Code|表示交易执行的返回代码，当交易成功时为0。如果交易失败，它将包含一个非零的具体错误代码。|
|Data|以16进制表示的字符串格式的交易数据。它通常包含一些与交易类型有关的信息。|
|RawLog|表示原始的、未解析的交易执行日志。它可能包含有关交易执行的详细信息。|
|Logs|表示经过解析后的交易执行日志。[ABCIMessageLogs](#71-abcimessagelogs类型)是日志消息的结构体数组，它提供了更具可读性的日志信息。|
|Info|提供有关提交的交易的附加信息。|
|GasWanted|表示执行该交易预期所需的最大Gas量。这是在开始执行交易之前提交的一个限制值。|
|GasUsed|表示实际执行此交易所消耗的Gas量。如果交易成功执行，此值通常小于等于GasWanted。|
|Tx|是一个包含交易详情的实例。[Tx](#72-tx类型)结构体可以包含如发送者、接收者、金额等有关交易的信息。|
|Timestamp|交易时间戳，表示交易创建的时间。|

## 7.1 ABCIMessageLogs类型
```go
type ABCIMessageLogs []ABCIMessageLog

type ABCIMessageLog struct {
	MsgIndex uint16 `json:"msg_index"`
	Log      string `json:"log"`

	// Events contains a slice of Event objects that were emitted during some
	// execution.
	Events StringEvents `json:"events"`
}
```

**ABCIMessageLogs的方法**:
|方法|描述|
|----|----|
|func (logs ABCIMessageLogs) String() (str string)|以字符串的方法输出日志信息|
|func (logs ABCIMessageLogs) MarshalToJson() ([]byte, error)|将日志信息输出位json格式|
|func (logs ABCIMessageLogs) MarshalJsonToBuffer(buf *bytes.Buffer) error|将日志信息转化位json格式，然后写入缓冲区buf中|

**ABCIMessageLog成员变量**：
|成员变量名|描述|
|---------|----|
|MsgIndex|表示消息的索引。这是一个无符号16位整数，用于标识日志中的特定消息。通过json:"msg_index"标签，MsgIndex将在JSON文件中使用"msg_index"字段名进行序列化。|
|Log|表示与ABCI消息相关的日志内容。有关于交易和操作的详细信息可能会储存在这个变量里。通过json:"log"标签，Log将在JSON文件中使用"log"字段名进行序列化。|
|Events|包含在ABCI消息执行过程中触发的多个事件。事件通常包含有关区块链操作状态更改的信息。通过json:"events"标签，Events将在.JSON文件中使用"events"字段名进行序列化。|

**ABCIMessageLog的方法**:
|方法|描述|
|----|----|
|func (log ABCIMessageLog) MarshalJsonToBuffer(buf *bytes.Buffer) error|将日志信息转化位json格式，然后写入缓冲区buf中|

## 7.2 Tx类型
Tx类型定义了一笔交易应该具备的基本方法。这是抽象了一笔可以在这个链上执行的交易。
```go
type Tx interface {
	// Gets the all the transaction's messages.
	GetMsgs() []Msg

	// ValidateBasic does a simple and lightweight validation check that doesn't
	// require access to any other information.
	ValidateBasic() error

	// Return tx gas price
	GetGasPrice() *big.Int

	// Return tx call function signature
	GetTxFnSignatureInfo() ([]byte, int)

	GetType() TransactionType

	GetSigners() []AccAddress

	GetGas() uint64

	GetRaw() []byte
	GetFrom() string
	GetNonce() uint64
	TxHash() []byte
	SetRaw([]byte)
	SetTxHash([]byte)
}
```
**方法含义**
|方法定义|描述|
|-------|----|
|GetMsgs() [][Msg](#73-typesmsg类型)|返回所有交易信息。这些信息可能包括发送者、接收者、金额，等等。每一笔交易都可能包含一个或多个信息。|
|ValidateBasic() error|做基础的有效性检查，这个检查是轻量级的，不需要额外的信息。可能会包括一些基础逻辑和数据完整性检查。|
|GetGasPrice() *big.Int|交易的gas价格。这是执行交易时需要支付的费用。|
|GetTxFnSignatureInfo() ([]byte, int)|返回交易调用函数的签名信息，包括签名的字节码和可能的索引。|
|GetType() TransactionType|返回交易的类型。这可能反映了交易完成的具体操作，如转账、合约创建等。|
|GetSigners() []AccAddress|返回交易的签名者的地址列表。这通常表示谁有权执行这笔交易。|
|GetGas() uint64|返回该交易所需要的gas。这通常基于交易的复杂性。|
|GetRaw() []byte|返回原始的交易信息。这可能是未签名或未序列化的原始交易信息，可能用于调试或签名。|
|GetFrom() string|返回代表交易发起人地址的字符串。在智能合约交易中，这通常是调用合约函数的账户地址。|
|GetNonce() uint64|返回交易的随机数，这是链上每个账户的计数器，用于防止交易重放。每次发送交易后，发送者的随机值会增加。|
|TxHash() []byte|返回交易的哈希值的字节表示。交易哈希是一种唯一标识交易的方式，通常将交易内容通过哈希函数得到。|
|SetRaw([]byte)|用于将一个原始交易的字节数据设置为某个交易。当你需要手动创建或修改交易的底层表示时，可能会使用这个函数。|
|SetTxHash([]byte)|这个方法用于设置交易的哈希值。在交易创建后、尚未添加到区块链之前，系统通常会自动设置交易的哈希。在某些特殊情况下，例如测试或者特定的开发输入，也可以手动设置交易的哈希。|

## 7.3 types.Msg类型
Msg接口定义了一个区块链网络中需要实现的基本消息类型。这些消息类型被用于表示各种交易行为，如代币转移、合约调用等。

```go
// Transactions messages must fulfill the Msg
type Msg interface {

	// Return the message type.
	// Must be alphanumeric or empty.
	Route() string

	// Returns a human-readable string for the message, intended for utilization
	// within tags
	Type() string

	// ValidateBasic does a simple validation check that
	// doesn't require access to any other information.
	ValidateBasic() error

	// Get the canonical byte representation of the Msg.
	GetSignBytes() []byte

	// Signers returns the addrs of signers that must sign.
	// CONTRACT: All signatures must be present to be valid.
	// CONTRACT: Returns addrs in some deterministic order.
	GetSigners() []AccAddress
}
```
**成员方法作用**:
|成员方法|描述|
|-------|----|
|Type() string|返回消息的类型，以人类可读的字符串表示。该类型描述了消息的具体功能，如“转账”、“创建合约”等。|
|Route() string|返回消息的路由类型。这通常是一个字母数字字符串，用于描述消息在区块链网络中的传递路线。例如，此值可能表示消息所属模块。|
|ValidateBasic() error|对消息执行基本的验证检查，这些检查不需要访问更多信息。例如，检查消息是否包含必要字段、字段值是否合法等。如果验证失败，则返回错误信息。|
|GetSignBytes() []byte|获取消息的签名字节表示。这些字节数据将用于签名和验证消息的来源。在大多数情况下，这些数据是从消息的内部字段生成。|
|GetSigners() []AccAddress|返回必须对消息签名的账户地址列表。这些地址需要按照某种确定性顺序返回。在许多区块链系统中，多个账户可以一起发起消息。这个方法就列出了这些共同发起人的账户地址。|



# 8 Validator类型

```go
type Validator struct {
	// address of the validator's operator; bech encoded in JSON
	OperatorAddress sdk.ValAddress `json:"operator_address" yaml:"operator_address"`
	// the consensus public key of the validator; bech encoded in JSON
	ConsPubKey crypto.PubKey `json:"consensus_pubkey" yaml:"consensus_pubkey"`
	// has the validator been jailed from bonded status?
	Jailed bool `json:"jailed" yaml:"jailed"`
	// validator status (bonded/unbonding/unbonded)
	Status sdk.BondStatus `json:"status" yaml:"status"`
	// delegated tokens (incl. self-delegation)
	Tokens sdk.Int `json:"tokens" yaml:"tokens"`
	// total shares added to a validator
	DelegatorShares sdk.Dec `json:"delegator_shares" yaml:"delegator_shares"`
	// description terms for the validator
	Description Description `json:"description" yaml:"description"`
	// if unbonding, height at which this validator has begun unbonding
	UnbondingHeight int64 `json:"unbonding_height" yaml:"unbonding_height"`
	// if unbonding, min time for the validator to complete unbonding
	UnbondingCompletionTime time.Time `json:"unbonding_time" yaml:"unbonding_time"`
	// commission parameters
	Commission Commission `json:"commission" yaml:"commission"`
	// validator's self declared minimum self delegation
	MinSelfDelegation sdk.Dec `json:"min_self_delegation" yaml:"min_self_delegation"`
}

func (v Validator) MarshalYAML() (interface{}, error)
```
## 8.1 Validator的成员变量
|成员变量|类型|描述|
|--------|---|----|
|OperatorAddress|[sdk.ValAddress](#811-sdkvaladdress类型)|验证节点地址，以JSON 编码的 bech|
|ConsPubKey|[crypto.PubKey]()|验证节点的公钥，用于在网络之间实现加密通信。|
|Jailed|bool| 这个标志用来表示验证器是否被监禁（在网络中暂时无法进行任何操作）, 通常在验证器进行恶意行为时被设置为真|
|Status|sdk.BondStatus(byte)|这个字段表示验证器的当前状态，可能的值为bonded（2--已绑定）, unbonding（1--解绑中）, 或者 unbonded（0--已解绑）。状态通常在验证器绑定/解绑代币时改变。|
|Tokens|sdk.Int(*big.Int)|这个字段表示验证器站方的总代币数量，包括由验证器自己代理的代币。|
|DelegatorShares|[sdk.Dec](#36-sdkdec类型)|表示验证器拥有的所有委托者的份数，即所有委托给验证器的代币数。|
|Description|[Description](#813-description类型)|验证节点的描述|
|UnbondingHeight|int64|如果验证器处于解绑状态，这表示验证器开始解绑的块高度。|
|UnbondingCompletionTime|time.Time|如果验证器处于解绑状态，这表示验证器预计完成解绑的时间。|
|Commission|[Commission](#814-commission类型)|验证器从委托者中收取的费用。通常以百分比形式表示。|
|MinSelfDelegation|[sdk.Dec](#36-sdkdec类型)|自我委托是验证人自己委托给他们验证器的资金。这个字段是验证器自我声明的最小自我委托值。|

### 8.1.1 sdk.ValAddress类型
```go
// 定义：
type ValAddress []byte
```
**成员方法**:
|方法定义|描述|
|------|-----|
|func (va ValAddress)</br> <font color=red>Equals(va2 Address)</font> bool|判断两个ValAddress是否相等|
|func (va ValAddress)</br> <font color=red>Empty()</font> bool|判断自身是否为空|
|func (va ValAddress) <font color=red>Marshal()</font></br> ([]byte, error)|获取原始地址字节(即返回ValAddress持有的[]byte)。 它是 protobuf 兼容性所必需的。|
|func (va *ValAddress) <font color=red>Unmarshal(data []byte)</font> error|设置ValAddress对应的[]byte的值，为了兼容protobuf|
|func (va ValAddress) <font color=red>MarshalJSON()</font> ([]byte, error)|使用 Bech32地址 编组为 JSON格式。|
|func (va *ValAddress) <font color=red>UnmarshalJSON(data []byte)</font> error|采用 Bech32 编码从 JSON 解组。|
|func (va ValAddress) <font color=red>MarshalYAML()</font> (interface{}, error)|使用 Bech32地址 编组为 YAML格式。|

### 8.1.2 crypto.PubKey类型
类型定义
```go
type PubKey interface {
	Address() Address
	Bytes() []byte
	VerifyBytes(msg []byte, sig []byte) bool
	Equals(PubKey) bool
}
```
**成员函数作用**
- <font color=red>Address() Address</font>:返回公钥的地址.公钥地址是通过对公钥应用特定的加密散列函数生成的。这个函数返回的类型是Address，也就是公钥的地址。
- <font color=red>Bytes() []byte</font>: 这个函数用于返回公钥的字节表示，即以字节数组的形式返回公钥。
- <font color=red>VerifyBytes(msg []byte, sig []byte) bool</font>: 这个函数用于验证给定的字节消息 msg 是否被与此公钥配对的私钥签署。sig 是一组字节（签名），将用于证明消息确实是由所指定的私钥签署的。如果验证成功，它将返回true；否则返回false。
参数msg []byte：这是你要验证的原始消息，它是一个字节切片。原始消息一般在发送前会由私钥生成一个对应的签名。
参数sig []byte：这是上面提到的原始消息对应的签名，它也是一个字节切片。这个签名是发送者用他的私钥对原始消息进行签名产生的。接收者可以用发送者的公钥来检查这个签名是否匹配原始消息。
- <font color=red>Equals(PubKey) bool</font>: 这个函数用于比较两个公钥是否相等。它接收另一个PubKey参数，如果两个公钥相等，它将返回true；否则，返回false。


### 8.1.3 Description类型
类型定义
```go
type Description struct {
	Moniker  string `json:"moniker" yaml:"moniker"`   // name
	Identity string `json:"identity" yaml:"identity"` // optional identity signature (ex. UPort or Keybase)
	Website  string `json:"website" yaml:"website"`   // optional website link
	Details  string `json:"details" yaml:"details"`   // optional details
}
```
|成员变量|描述|
|-------|----|
|Moniker|节点的名称。这是自定义的、独一无二的名称，用于在网络中唯一标识特定的节点|
|Identity|选字段，用于标识签名，如 UPort 或 Keybase 等。这种身份验证信息可以增强验证者的信任和可识别性|
|Website|可选字段，可以提供一个网站链接。这个链接通常会引导至一个有关验证者的更详细的介绍页面，包含如验证者的操作方式，策略，费用等信息。|
|Details|可选字段，可以输入有关验证者节点的更多的详细描述，比如他们的目标，政策，或者其他验证者特有的特色。|

### 8.1.4 Commission类型
```go
type(
    Commission struct {
        CommissionRates `json:"commission_rates" yaml:"commission_rates"`
        UpdateTime      time.Time `json:"update_time" yaml:"update_time"` // the last time the commission rate was changed
    }
    
    CommissionRates struct {
        // the commission rate charged to delegators, as a fraction
        Rate sdk.Dec `json:"rate" yaml:"rate"`
        // maximum commission rate which validator can ever charge, as a fraction
        MaxRate sdk.Dec `json:"max_rate" yaml:"max_rate"`
        // maximum daily increase of the validator commission, as a fraction
        MaxChangeRate sdk.Dec `json:"max_change_rate" yaml:"max_change_rate"`
    }
)
```

**成员变量**：
|名称|类型|描述|
|----|----|----|
|CommissionRates|CommissionRates|百分比|
|UpdateTime|time.Time|百分比更新的时间|

**CommissionRates类型**：
|成员变量名|类型|描述|
|---------|----|----|
|Rate|[sdk.Dec](#36-sdkdec类型)|该验证节点（validator）向他的代表（delegator）收取的委任费率。它是一个小数表示的比率。如果一个人或机构愿意将他们的数字货币委托给验证节点，他们将需要支付这个比率的费用。|
|MaxRate|[sdk.Dec](#36-sdkdec类型)|验证节点能收取的最高委任费率。在任何情况下，验证节点都不能超过这个费率来收取代表的费用。|
|MaxChangeRate|[sdk.Dec](#36-sdkdec类型)|表示验证节点的每日最大委任费率变化（此处应为委任费率增长的幅度）。也就是说，从一天到下一天，验证节点不能大幅增加他们的委任费率超过这个限制。|

# 9 types.DelegatorResponse类型
```go
type DelegatorResponse struct {
	DelegatorAddress     sdk.AccAddress   `json:"delegator_address" yaml:"delegator_address"`
	ValidatorAddresses   []sdk.ValAddress `json:"validator_address" yaml:"validator_address"`
	Shares               sdk.Dec          `json:"shares" yaml:"shares"`
	Tokens               sdk.Dec          `json:"tokens" yaml:"tokens"`
	UnbondedTokens       sdk.Dec          `json:"unbonded_tokens" yaml:"unbonded_tokens"`
	CompletionTime       time.Time        `json:"completion_time" yaml:"completion_time"`
	IsProxy              bool             `json:"is_proxy" yaml:"is_proxy"`
	TotalDelegatedTokens sdk.Dec          `json:"total_delegated_tokens" yaml:"total_delegated_tokens"`
	ProxyAddress         sdk.AccAddress   `json:"proxy_address" yaml:"proxy_address"`
}
```
**各个成员变量的含义**：
|成员变量名称|类型|描述|
|-----------|----|----|
|DelegatorAddress|[sdk.AccAddress](#21-typesaccaddress类型)|委托人地址|
|ValidatorAddresses|[[]sdk.ValAddress](#21-typesaccaddress类型)|验证人地址列表，包含了被委托人选定的那些验证人的地址|
|Shares|[sdk.Dec](#36-sdkdec类型)|委托人在每个被委托的验证人上的份额。|
|Tokens|[sdk.Dec](#36-sdkdec类型)|描述委托人所委托代币总数量的字段。|
|UnbondedTokens|[sdk.Dec](#36-sdkdec类型)|代表了尚未锁定或未结算的代币数量，这些代币可能刚被撤销委托，或者正在等待被委托。|
|CompletionTime|time.Time|表示的是完成解除委托的时间，又或者是下一次奖励发放的时间。|
|IsProxy|bool|表示的是这个委托人是否是一个代理，如果是，他可能代表其他用户进行委托操作。|
|TotalDelegatedTokens|[sdk.Dec](#36-sdkdec类型)|委托人的所有被委托的代币总数。|
|ProxyAddress|[sdk.AccAddress](#21-typesaccaddress类型)|代理的地址，如果此委托人是代理的话，这个字段将被使用。|

# 10 types.TokenPair类型

**类型定义**

TokenPair这个结构表示一对交易所支持的代币或资产（比如ETH/USDT）
```go
type TokenPair struct {
	BaseAssetSymbol  string         `json:"base_asset_symbol"`
	QuoteAssetSymbol string         `json:"quote_asset_symbol"`
	InitPrice        sdk.Dec        `json:"price"`
	MaxPriceDigit    int64          `json:"max_price_digit"`
	MaxQuantityDigit int64          `json:"max_size_digit"`
	MinQuantity      sdk.Dec        `json:"min_trade_size"`
	ID               uint64         `json:"token_pair_id"`
	Delisting        bool           `json:"delisting"`
	Owner            sdk.AccAddress `json:"owner"`
	Deposits         sdk.SysCoin    `json:"deposits"`
	BlockHeight      int64          `json:"block_height"`
}
```

**成员变量定义**
|成员名称|类型|描述|
|-------|----|----|
|BaseAssetSymbol|string|基础资产的标识符|
|QuoteAssetSymbol|string|报价资产（或计价资产）的标识符。例如，在ETH/USDT交易对中，ETH是基础资产，USDT是报价资产。|
|InitPrice|[sdk.Dec](#36-sdkdec类型)|初始价格，是在该交易对首次上市时的价格。|
|MaxPriceDigit|int64|最大价格位数，这个成员变量规定了某个交易对报价的最大小数位数。例如，如果MaxPriceDigit的值为2，那么这个交易对的价格可以有最多两位小数。|
|MaxQuantityDigit|int64|最大交易量位数，规定了某个交易对交易数量的最大小数位数。例如，如果MaxQuantityDigit的值为2，那么这个交易对的交易量可以有最多两位小数。|
|MinQuantity|[sdk.Dec](#36-sdkdec类型)|这个成员变量规定了某个交易对的最小交易量。例如，如果MinQuantity的值为0.01，那么这个交易对的最小交易量就是0.01。|
|ID|uint64|交易对ID，它是这个交易对在交易所的唯一标识。|
|Delisting|bool|表示这个交易对是否已经下市。如果为true，表示已经下市；否则表示仍在市场上。|
|Owner|[sdk.AccAddress](#21-typesaccaddress类型)|交易对所有者的账户地址。这通常是创建这个交易对的人或组织。|
|Deposits|[sdk.SysCoin](#3-coins类型)|为创建和保持这个交易对，所有者所需要存放的抵押物。|
|BlockHeight|int64|这个交易对最后一次状态更新的区块高度。|

**注意**：
- 以上成员变量中的（MaxPriceDigit,MaxQuantityDigit,MinQuantity）区别在于，MaxPriceDigit和MaxQuantityDigit决定了报价和交易量的精度，即你可以设定到多细的价格和交易量。而MinQuantity决定了交易量的下限，即你至少需要交易多少单位。这三个变量都为交易平台的运营提供了一定程度的灵活性。

# 11 ctypes.ResultTxSearch类型
```go
type ResultTxSearch struct {
	Txs        []*ResultTx `json:"txs"`
	TotalCount int         `json:"total_count"`
}
```
**成员变量**
|成员名称|类型|描述|
|-------|----|----|
|Txs|[]*[ResultTx](#111-resulttx类型)|交易记录列表|
|TotalCount|int|表示搜索结果中满足特定条件的交易的总数。注意，由于某些搜索条件可能会匹配到较多的交易记录，因此返回的 Txs 切片长度可能受到分页限制。TotalCount 变量提供了在所有满足查询条件的交易中的个数。你可以使用 TotalCount 来确定是否需要翻页以获取更多结果。|

## 11.1 ResultTx类型
```go
type ResultTx struct {
	Hash     bytes.HexBytes         `json:"hash"`
	Height   int64                  `json:"height"`
	Index    uint32                 `json:"index"`
	TxResult abci.ResponseDeliverTx `json:"tx_result"`
	Tx       types.Tx               `json:"tx"`
	Proof    types.TxProof          `json:"proof,omitempty"`
}
```

**成员函数**:
|成员名称|类型|描述|
|-------|----|----|
|Hash|bytes.HexBytes|交易的哈希值|
|Height|int64|交易在区块链中的高度|
|Index|uint32|表示交易在其所属区块中的索引位置。结合 Height，可以准确地定位整个链上的某一笔交易。|
|TxResult|[abci.ResponseDeliverTx](#112-abciresponsedelivertx类型)|表示交易执行的结果。这包括执行状态、日志、事件、gas费用，交易方、金额等额外信息，帮助用户了解交易执行情况。|
|Tx|[types.Tx](#115-exchaintypestx类型)|表示原始交易对象。|
|Proof|types.TxProof|一个可选的 types.TxProof 类型的变量，表示交易的默克尔证明。这一证明确保了交易数据的一致性和完整性，有时用于轻量客户端验证。如果在 API 请求中包含了 prove 参数（例如，通过 Tendermint RPC 的 /tx_search 端点），这个字段会被填充。|

## 11.2 abci.ResponseDeliverTx类型
```go
type ResponseDeliverTx struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Log                  string   `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info                 string   `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	GasWanted            int64    `protobuf:"varint,5,opt,name=gas_wanted,json=gas_wanted,proto3" json:"gas_wanted,omitempty"`
	GasUsed              int64    `protobuf:"varint,6,opt,name=gas_used,json=gas_used,proto3" json:"gas_used,omitempty"`
	Events               []Event  `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
	Codespace            string   `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```

**成员变量**:
|成员名称|类型|描述|
|-------|----|----|
|Code|uint32|表示交易的执行结果的代码，类型为 uint32。如果 code 是 0 ，那么代表了交易的成功执行；否则，表示出现错误。具体的错误代码和含义由应用定义。|
|Data|[]type|保存了由交易处理程序返回的任意数据。应用程序可以使用此字段返回任何有用的数据。|
|Log|string|保存了交易处理过程中生成的信息，类型为 string。这些信息通常用于调试和跟踪交易。|
|Info|string|包含交易处理时的附加信息|
|GasWanted|int64|表示交易执行期望消耗的 gas 的量，由交易的发起者设定。|
|GasUsed|int64|实际消耗的 gas 的量|
|Events|[][Event](#113-event类型)|存储交易执行过程中生成的事件，类型为 Event 切片。这些事件可以用于跟踪交易的处理过程，或者通知外部系统。|
|Codespace|string|与 code 相关的命名空间，类型为 string。这可以帮助定位问题的来源。例如，不同的模块可以定义自己的 codespace ，使得出错时更容易找出问题的源头。|
|XXX_NoUnkeyedLiteral|struct{}|由 protobuf 自动生成的，用以防止未键化字面值的编码，类型为 struct{}。这是应对特殊情况的安全检查，确保没有非法的未键化的值被编码。|
|XXX_unrecognized|[]byte| protobuf 的一个自动生成字段，用来保存在解析过程中遇到但未在目标类型中定义的字段的数据，类型为 []byte。这样就保留了反序列化时未知字段的数据，使得后续如果新增字段，在数据向前兼容性上不会发生问题。|
|XXX_sizecache|int32|protobuf 自动生成的字段，用于缓存序列化数据的大小，类型为 int32 。在进行 protobuf 序列化时，它可以提高序列化性能，因为在计算序列化结果大小时可以避免重复的计算。|

**注意**
以上的后3个成员变量，这些 XXX_ 开头的字段是由 Go 的 Protobuf v1 版本生成的，目前的最新 Protobuf v2 版本为了保持更清晰的 API，已经移除了这些字段。

## 11.3 Event类型
```go
type Event struct {
	Type                 string    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Attributes           []kv.Pair `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}
```
**成员变量**
|成员名称|类型|描述|
|-------|----|----|
|Type|string|描述事件的类别，例如 “transfer” 表示转账事件。|
|Attributes|[]kv.Pair|事件的一组属性，属性为键值对（kv.Pair类型）。这些属性提供了与事件相关的详细信息，<font color=red>例如从哪个账户到哪个账户的转账金额等。</font>|

|Type的值|Type的含义|
|--------|---------|
|transfer|交易类型为转账|
|message||
|commission||
|rewards||
|liveness||
|delegate|委托，执行Staking().Deposit方法会产生这个事件|

## 11.4 kv.Pair类型
```go
type Pair struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```
|Key的值|Key值含义|对应Value|
|-------|--------|---------|
|


## 11.5 exchain/types.Tx类型
```go
type Tx []byte
```

**成员函数**:
|函数|描述|
|----|----|
|func (tx Tx) Hash(height int64) []byte|返回交易的hash值|
|func (tx Tx) String() string|将交易类型输出为字符串表示|


# 12 types.BookRes类型
```go
BookRes     = orderkeeper.BookRes

type BookRes struct {
	Asks []BookResItem `json:"asks"`
	Bids []BookResItem `json:"bids"`
}
```

**BookRes成员变量**
|成员名称|类型|描述|
|-------|----|----|
|Asks|[][BookResItem](#121-bookresitem类型)|卖单,最低价位在顶端|
|Bids|[][BookResItem](#121-bookresitem类型)|买单,最高价位在顶端|

## 12.1 BookResItem类型
```go
type BookResItem struct {
	Price    string `json:"price"`
	Quantity string `json:"quantity"`
}
```

**BookResItem**
|成员名称|类型|描述|
|-------|----|----|
|Price|string|买单或卖单的价格|
|Quantity|string|买单或卖单的数量|


# 13 types.OrderDetail类型
```go
OrderDetail = ordertypes.Order

type Order struct {
	TxHash            string         `json:"txhash"`           // txHash of the place order tx
	OrderID           string         `json:"order_id"`         // order id
	Sender            sdk.AccAddress `json:"sender"`           // order maker address
	Product           string         `json:"product"`          // product for trading pair
	Side              string         `json:"side"`             // BUY/SELL
	Price             sdk.Dec        `json:"price"`            // price of the order
	Quantity          sdk.Dec        `json:"quantity"`         // quantity of the order
	Status            int64          `json:"status"`           // order status, see OrderStatusXXX
	FilledAvgPrice    sdk.Dec        `json:"filled_avg_price"` // filled average price
	RemainQuantity    sdk.Dec        `json:"remain_quantity"`  // Remaining quantity of the order
	RemainLocked      sdk.Dec        `json:"remain_locked"`    // Remaining locked quantity of token
	Timestamp         int64          `json:"timestamp"`        // created timestamp
	OrderExpireBlocks int64          `json:"order_expire_blocks"`
	FeePerBlock       sdk.SysCoin    `json:"fee_per_block"`
	ExtraInfo         string         `json:"extra_info"` // extra info of order in json format
}
```

# 14 types.Block类型
```go
Block = tmtypes.Block

// Block defines the atomic unit of a Tendermint blockchain.
type Block struct {
	mtx sync.Mutex

	Header     `json:"header"`
	Data       `json:"data"`
	Evidence   EvidenceData `json:"evidence"`
	LastCommit *Commit      `json:"last_commit"`
}
```

**成员变量**
|成员变量名|类型|描述|
|---------|----|----|
|mmtx|sync.Mutex|这是一个互斥锁，用于确保 Block 结构体在修改时的线程安全性。|
|Header|[Header](#141-header类型)|字段代表了区块头的信息。区块头通常含有区块的元数据，比如区块版本、链的版本、前一个区块的哈希值、当前区块的哈希值、Merkle 树的根哈希值、时间戳等。|
|Data|[Data](#146-data类型)|含实际的交易数据，即区块所包含的一系列交易记录。|
|Evidence|[EvidenceData](#148-evidencedata类型)|用于存放证据数据，这通常指的是与不正当行为相关的信息，例如双重签名或其他恶意活动的证据。|
|LastCommit|*[Commit](#1411-Commit类型)|表示上一个区块的最终提交信息，或者说是对上一个区块的确认信息。Commit 结构通常包含了一系列签名，表明网络中的验证者对上一个区块的有效性达成了一致。|

## 14.1 Header类型

```go
type Header struct {
	// basic block info
	Version version.Consensus `json:"version"`
	ChainID string            `json:"chain_id"`
	Height  int64             `json:"height"`
	Time    time.Time         `json:"time"`

	// prev block info
	LastBlockID BlockID `json:"last_block_id"`

	// hashes of block data
	LastCommitHash tmbytes.HexBytes `json:"last_commit_hash"` // commit from validators from the last block
	DataHash       tmbytes.HexBytes `json:"data_hash"`        // transactions

	// hashes from the app output from the prev block
	ValidatorsHash     tmbytes.HexBytes `json:"validators_hash"`      // validators for the current block
	NextValidatorsHash tmbytes.HexBytes `json:"next_validators_hash"` // validators for the next block
	ConsensusHash      tmbytes.HexBytes `json:"consensus_hash"`       // consensus params for current block
	AppHash            tmbytes.HexBytes `json:"app_hash"`             // state after txs from the previous block
	// root hash of all results from the txs from the previous block
	LastResultsHash tmbytes.HexBytes `json:"last_results_hash"`

	// consensus info
	EvidenceHash    tmbytes.HexBytes `json:"evidence_hash"`    // evidence included in the block
	ProposerAddress Address          `json:"proposer_address"` // original proposer of the block
}
```

**Header成员变量**
|成员变量名称|类型|描述|
|-----------|----|----|
|Version|[version.Consensus](#142-versionconsensus类型)|区块协议的版本，即维护区块链记录的软件使用的共识算法的版本。|
|ChainID|string|区块链ID|
|Height|int64|区块链的高度|
|Time|time.Time|区块创建的时间|
|LastBlockID|[BlockID](#144-blockid类型)|指向这个区块前面一个区块的标识，通常包括前一个区块的哈希值和部分元数据。|
|LastCommitHash|tmbytes.HexBytes|上一个区块的确认信息的哈希值，通常由验证者的签名集合构成。|
|DataHash|tmbytes.HexBytes|这是当前区块中所包含的所有交易的 Merkle 树根的哈希值。|
|ValidatorsHash|tmbytes.HexBytes|这是当前区块验证者列表的哈希值。|
|NextValidatorsHash|tmbytes.HexBytes|这是下一个区块验证者列表的哈希值。|
|ConsensusHash|tmbytes.HexBytes|当前区块使用的共识规则的哈希值。|
|AppHash|tmbytes.HexBytes|这是应用层（例如智能合约状态）处理完这个区块里的所有交易后的最终状态。|
|LastResultsHash|tmbytes.HexBytes|这是前一个区块中所有交易结果的 Merkle 树根的哈希值。|
|EvidenceHash|tmbytes.HexBytes|这是区块中包含的任何证据（例如，双花或恶意行为）的哈希值。|
|ProposerAddress|Adress（bytes.HexBytes）|这是提出该区块的验证者地址。在 Tendermint PoS 共识机制中，验证者会轮流提出新的区块。|

这些成员变量共同组成了区块头部信息，为区块链提供了关键的可验证性和链的完整性。通过这些信息，参与者可以追踪每个区块的起源，验证交易，确认验证者身份，以及确保区块未被篡改。

## 14.2 version.Consensus类型
Consensus 结构的版本字段通常需要在链上达成共识，并确保所有的参与者都在相同的协议版本上进行操作。在软件升级过程或者在不同网络间进行交流时，这些版本信息至关重要，它们确保区块和交易能够在全节点之间被正确的验证和处理。

在一个区块头（Header）中，这个版本信息会明确指示验证和同步区块数据时必需遵守的规则。当网络中的节点运行着不同版本的软件时，它可以帮助节点决定是否需要升级，以便与整个网络保持兼容。
```go
// 捕获处理区块链中区块的共识规则，
//包括所有区块链数据结构和应用程序状态转换机的规则。
//用来追踪区块链共识层（以及可能的应用层）的版本变化
type Consensus struct {
	Block Protocol `json:"block"`
	App   Protocol `json:"app"`
}
```

**成员变量**
|成员变量名|类型|密码|
|---------|----|----|
|Block|[Protocol](#143-protocol类型)|这个字段表明了区块结构或区块链协议层的版本。由于区块链的设计可能会随着时间更迭而升级，Block 字段帮助区分不同版本的区块数据结构。这样，如果出现了协议升级或者硬分叉，节点可以正确解析新旧区块数据。|
|App|[Protocol](#143-protocol类型)|这个字段指的是应用层协议的版本，也就是区块链上运行的应用程序，例如智能合约或者状态机的版本。更改 App 版本可以表明应用层的状态或逻辑出现了改动。|

## 14.3 Protocol类型
```go
type Protocol uint64
```

**方法**:
|方法定义|描述|
|--------|---|
|func (p Protocol) Uint64() uint64|返回uint64类型的版本信息|

## 14.4 BlockID类型
```go
// BlockID defines the unique ID of a block as its Hash and its PartSetHeader
type BlockID struct {
	Hash        tmbytes.HexBytes `json:"hash"`
	PartsHeader PartSetHeader    `json:"parts"`
}
```

**成员函数描述**:
|成员函数名称|类型|描述|
|-----------|----|---|
|Hash|tmbytes.HexBytes|区块的哈希值|
|PartsHeader|[PartSetHeader](#145-partsetheader类型)| 这是区块的分片头部信息。为了在网络中更有效地传播区块，特别是容量较大的区块，Tendermint 技术利用分片技术将区块切分为多个部分（parts）。每个区块部分都有自己的哈希值，而 PartSetHeader 则包括所有这些部分的集合的哈希值，以及分片的数量。这使得节点可以并行下载区块的不同部分，并通过验证分片的哈希确定所有部分的完整性及正确性。|

## 14.5 PartSetHeader类型
```go
type PartSetHeader struct {
	Total int              `json:"total"`
	Hash  tmbytes.HexBytes `json:"hash"`
}
```

**成员变量**:
|成员变量名称|类型|描述|
|-----------|----|---|
|Total|int|这个字段表示区块被分割成了多少个部分（part）。每个部分包含了区块的一个片段，通过总数可以知道需收集多少个部分才能组成完整的区块。|
|Hash|tmbytes.HexBytes|所有分片的加密哈希值的集合的哈希。换句话说，它是对这些分片的头部数据进行哈希处理后的结果，这个集合通常表现为一个Merkle树或其他哈希树的根。该哈希保证了区块的各个分片在网络传输过程中维持其完整性和一致性。|

## 14.6 Data类型
类型定义于 github.com/okex/exchain/libs/tendermint/types
存储了区块中包含的所有交易。它是区块链共识和执行交易过程的重要组成部分。尽管所有交易都包含在区块中，但它们是否都是有效的则需要在执行交易时进行验证。Data 结构体帮助节点就交易的顺序达成共识，并允许它们在稍后执行这些交易来更新区块链的状态。
```go
// Data 包含在块中的事务集
type Data struct {

	// Txs that will be applied by state @ block.Height+1.
	// NOTE: not all txs here are valid.  We're just agreeing on the order first.
	// This means that block.AppHash does not include these txs.
	Txs Txs `json:"txs"`

	// Volatile
	hash tmbytes.HexBytes
}
```

**成员变量**:
|成员变量名|类型|描述|
|---------|----|----|
|Txs|[Txs](#147-txs类型)|这是一个交易列表，这些交易将会在下一个区块（即高度为 block.Height+1）被应用到状态机上。值得注意的是，并不是所有在这个列表中的交易都是有效的。Tendermint 首先在节点之间就交易的顺序达成共识，然后才会验证这些交易的有效性（在执行交易的过程中）。这意味着，某个区块的 AppHash（应用哈希，是区块头的一部分，反映了执行交易后的应用状态）并不包括这些交易本身的数据。|
|hash|tmbytes.HexBytes|这是一个内部使用的、非导出的字段（在 Go 语言中，以小写字母开头的标识符是私有的或者说是非导出的）。它表示交易列表 Txs 的哈希值。这个哈希值是易变的，通常在需要时计算（例如，当事务被添加到区块中）。这个哈希值用于在内部验证交易数据的完整性和一致性。|

## 14.7 Txs类型
```go
type Txs []Tx

type Tx []byte
```

**Txs类型的成员函数**
|成员函数|描述|
|-------|----|
|func (txs Txs) Hash(height int64) []byte|获取交易列表的hash值|
|func (txs Txs) Index(tx Tx) int|获取指定Tx在列表中的索引|
|func (txs Txs) IndexByHash(hash []byte, height int64) int|返回hash的值等于自身Tx成员对应的索引，没有找到返回-1|
|func (txs Txs) Proof(i int, height int64) TxProof|返回此节点的简单默克尔证明。|

**Tx类型的成员函数**
|成员函数|描述|
|-------|----|
|func (tx Tx) Hash(height int64) []byte|计算有线编码事务的TMHASH哈希值。|
|func (tx Tx) String() string|以字符串形式返回十六进制编码的事务。|

## 14.8 EvidenceData类型
包含验证器恶意错误操作的任何证据
```go
type EvidenceData struct {
	Evidence EvidenceList `json:"evidence"`

	// Volatile
	hash tmbytes.HexBytes
}
```

**成员变量**
|成员变量名称|类型|描述|
|-----------|----|----|
|Evidence|EvidenceList|证据列表|
|hash|tmbytes.HexBytes|用于验证数据完整性的hash值|

## 14.9 EvidenceList类型
```go
type EvidenceList []Evidence
```
**成员函数**
|成员函数|描述|
|-------|----|
|func (evl EvidenceList) Hash() []byte|返回证据列表的hash值|
|func (evl EvidenceList) String() string|将证据以字符串的形式输出|
|func (evl EvidenceList) Has(evidence Evidence) bool|判断证据是否存在本列表中|

## 14.10 Evidence类型
```go
// Evidence represents any provable malicious activity by a validator
type Evidence interface {
	Height() int64                                     // height of the equivocation
	
	Time() time.Time                                   // time of the equivocation
	
	Address() []byte                                   // address of the equivocating validator
	
	Bytes() []byte                                     // bytes which comprise the evidence
	
	Hash() []byte                                      // hash of the evidence
	
	Verify(chainID string, pubKey crypto.PubKey) error // verify the evidence
	
	Equal(Evidence) bool                               // check equality of evidence

	ValidateBasic() error
	String() string
}
```

## 14.11 Commit类型
表示一个区块得到了验证者集合的证实和承诺，它证明了一个区块已经达到了足够的投票并被提交到区块链上。
```go
// Commit contains the evidence that a block was committed by a set of validators.
// NOTE: Commit is empty for height 1, but never nil.
type Commit struct {
	// NOTE: The signatures are in order of address to preserve the bonded
	// ValidatorSet order.
	// Any peer with a block can gossip signatures by index with a peer without
	// recalculating the active ValidatorSet.
	Height     int64       `json:"height"`
	Round      int         `json:"round"`
	BlockID    BlockID     `json:"block_id"`
	Signatures []CommitSig `json:"signatures"`

	// Memoized in first call to corresponding method.
	// NOTE: can't memoize in constructor because constructor isn't used for
	// unmarshaling.
	hash     tmbytes.HexBytes
	bitArray *bits.BitArray
}
```

**成员变量**:
|成员变量名称|类型|描述|
|-----------|----|----|
|Height|int64|表示哪个区块高度的区块被验证和提交|
|Round|int| 在 Tendermint 验证区块的过程中，可能会经历多轮投票，Round 字段表示在哪一轮投票中该区块被提交。这是为了在验证者之间达成一致而可能需要的多轮通信过程的一部分。|
|BlockID|[BlockID](#144-blockid类型)|表示被提交的区块的身份信息，通常包含了区块的哈希及其部分集合的哈希。|
|Signatures|[][CommitSig](#1412-commitsig类型)|这是一个 CommitSig 类型的数组，其中包含了对该区块的投票/承诺。每个 CommitSig 包含了一个验证者对区块的签名，证明该验证者同意新增该区块到区块链上。这些签名按照验证者地址的顺序排列，以保持绑定的 ValidatorSet（验证者集合）的顺序。|
|hash|tmbytes.HexBytes|这是内部使用的字段，它被用来存储Commit结构的哈希值。注意这个字段不是用于序列化的结构的一部分，而是在需要时计算的。|
|bitArray|*bits.BitArray|内部使用的字段，它代表了一个位数组，用来优化对签名的处理。例如，它可以表示哪些验证者已经对区块进行了签名。|

在实际的 Tendermint 区块链协议中，一个区块在加入区块链之前需要达成足够的共识，即超出2/3的验证者同意。Commit结构体记录了这个共识过程，并且通常随着每个区块一起存储下来，作为证明那个区块在网络中被认可和验证的证据。对于第一个区块（高度1），由于它是创世区块，通常不需要这样的证实，因此对应的Commit可能是空的，但从概念上来讲不会是nil，以保持数据结构的一致性。

## 14.12 CommitSig类型
```go
// CommitSig is a part of the Vote included in a Commit.
type CommitSig struct {
	BlockIDFlag      BlockIDFlag `json:"block_id_flag"`
	ValidatorAddress Address     `json:"validator_address"`
	Timestamp        time.Time   `json:"timestamp"`
	Signature        []byte      `json:"signature"`
}
```

**成员变量**
|成员变量名称|类型|描述|
|-----------|----|----|
|BlockIDFlag|BlockIDFlag(byte)| 这个字段表示投票的类型。在 Tendermint 的共识机制中，可能有不同类型的投票，例如 BlockIDFlag 可以表示投票是针对提议的区块、是预投票（prevote）还是预提交（precommit），又或者表示没有投票（因为没有接收到提案或者因为收到了多个提案）。|
|ValidatorAddress|Address（bytes.HexBytes）|验证者地址|
|Timestamp|time.Time|记录了验证者投票的时间。这个时间信息用于记录验证者签名的大致时间，并且可以用来检查投票是否符合时间窗口的规范。|
|Signature|[]byte|这是验证者对区块（以及它所在的投票的特定轮次）进行签名的实际字节序列。这个签名用于验证在共识过程中消息的授权。只有当来自足够数量的验证者的有效签名被收集起来时，该区块才被认为是有效的，并可以被添加到区块链上。|

# 15 types.ResultBlockResults类型
ResultBlockResults结构体记录了一个区块的执行结果、交易结果、区块级事件以及相关的共识参数和验证者更新。
```go
// ABCI results from a block
type ResultBlockResults struct {
	Height                int64                     `json:"height"`
	TxsResults            []*abci.ResponseDeliverTx `json:"txs_results"`
	BeginBlockEvents      []abci.Event              `json:"begin_block_events"`
	EndBlockEvents        []abci.Event              `json:"end_block_events"`
	ValidatorUpdates      []abci.ValidatorUpdate    `json:"validator_updates"`
	ConsensusParamUpdates *abci.ConsensusParams     `json:"consensus_param_updates"`
}
```

**成员名称**：
|成员变量名|类型|描述|
|---------|----|----|
|Height|int64|区块的高度|
|TxsResults|[]*[abci.ResponseDeliverTx](#112-abciresponsedelivertx类型)|这是一个存储abci.ResponseDeliverTx类型的指针数组。每个元素表示一个交易在应用程序中执行的结果。包含了交易执行产生的事件、费用、日志等信息。|
|BeginBlockEvents|[][abci.Event](#113-event类型)|(区块开始时事件)：一个abci.Event类型的数组，表示在区块开始执行时发生的事件。这些事件和交易无关，主要用于区块层级的日志和事件记录。|
|EndBlockEvents|[][abci.Event](#113-event类型)| (区块结束时事件)：一个abci.Event类型的数组，表示在区块执行结束时发生的事件。类似于BeginBlockEvents，这些事件也用于区块层级的日志和事件记录。|
|ValidatorUpdates|[][abci.ValidatorUpdate](#151-abcivalidatorupdate类型)|(验证者更新)：一个abci.ValidatorUpdate类型的数组，表示在此区块中进行的验证者节点的变动信息。包括新增的验证者节点和被移除的验证者节点，以及权重变化等信息。|
|ConsensusParamUpdates|*abci.ConsensusParams | (共识参数更新)：一个指向abci.ConsensusParams结构体的指针。包含了与共识相关的参数更新，如块大小限制、证据参数或验证者参数等。|

## 15.1 abci.ValidatorUpdate类型
表示验证者节点的更新信息。
```go
// ValidatorUpdate
type ValidatorUpdate struct {
	PubKey               PubKey   `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key"`
	Power                int64    `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```

**成员变量**：
|成员变量名称|类型|描述|
|-----------|----|----|
|PubKey|PubKey|表示验证者节点的公钥。这个公钥用于签名验证以确保来自验证者节点的消息的安全性和可靠性。|
|Power|int64|在共识引擎中，每个验证者节点都有一个权重，该权重用于计算其在共识过程中的投票权。权重值通常与验证者节点的某种权益（如抵押代币数量）成正比。|

## 15.2 PubKey类型
```go
type PubKey struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```

**参数名称**：
|成员变量名|类型|描述|
|---------|----|----|
|Type|string|表示公钥的类型或算法，如 “ed25519” 或 “secp256k1” 等。这个字段通知系统应如何解释 Data 字段中的公钥数据。|
|Data|[]byte|保存实际的公钥数据。这是一个字节序列，具体值取决于公钥的类型和使用的加密算法。|


# 16 types.OrderDetail类型
```go
// nolint
type Order struct {
	TxHash            string         `json:"txhash"`           // 订单的额外信息，以 JSON 格式表示的额外订单信息
	OrderID           string         `json:"order_id"`         // 订单的唯一标识符
	Sender            sdk.AccAddress `json:"sender"`           // 下单者的账户地址
	Product           string         `json:"product"`          // 交易对的产品名称
	Side              string         `json:"side"`             // 订单的类型，可以是 “BUY”（买单）或 “SELL”（卖单）
	Price             sdk.Dec        `json:"price"`            // 订单的价格
	Quantity          sdk.Dec        `json:"quantity"`         // 订单的数量
	Status            int64          `json:"status"`           // 订单的状态，可能的取值可以参考 OrderStatusXXX
	FilledAvgPrice    sdk.Dec        `json:"filled_avg_price"` // 已成交部分的加权平均价格
	RemainQuantity    sdk.Dec        `json:"remain_quantity"`  // 剩余未成交部分的数量
	RemainLocked      sdk.Dec        `json:"remain_locked"`    // 剩余未成交部分锁定的代币数量
	Timestamp         int64          `json:"timestamp"`        // 订单创建的时间戳
	OrderExpireBlocks int64          `json:"order_expire_blocks"` // 订单的过期区块数，即多少个区块后订单自动过期
	FeePerBlock       sdk.SysCoin    `json:"fee_per_block"` //每个区块的手续费
	ExtraInfo         string         `json:"extra_info"` // 订单的额外信息，以 JSON 格式表示的额外订单信息
}
```

# 17 types.FarmPool类型
```go
type FarmPool struct {
	Owner         sdk.AccAddress `json:"owner"`
	Name          string         `json:"name"`
	MinLockAmount sdk.SysCoin    `json:"min_lock_amount"`
	DepositAmount sdk.SysCoin    `json:"deposit_amount"`
	// sum of LockInfo.Amount
	TotalValueLocked        sdk.SysCoin       `json:"total_value_locked"`
	YieldedTokenInfos       YieldedTokenInfos `json:"yielded_token_infos"`
	TotalAccumulatedRewards sdk.SysCoins      `json:"total_accumulated_rewards"`
}
```

**成员变量**
|成员变量名称|类型|描述|
|-----------|-----|---|
|Owner|sdk.AccAddress|FarmPool矿池所属者地址信息|
|Name|string|FarmPool矿池的名称|
|MinLockAmount|sdk.SysCoin|锁定资产的最小数量要求，即参与 FarmPool 的用户需要锁定的最小资产数量。|
|DepositAmount|sdk.SysCoin|FarmPool 中存款的数量。|
|TotalValueLocked|sdk.SysCoin |总的锁定价值，表示当前 FarmPool 中所有用户锁定资产的总价值。|
|YieldedTokenInfos|[YieldedTokenInfos](#172-yieldedtokeninfos类型)|产出代币信息，其中包括产出的代币信息，如产出代币的类型、数量等。|
|TotalAccumulatedRewards|sdk.SysCoins|总累积奖励，表示该 FarmPool 中累积的所有奖励的总和，以 sdk.SysCoins 的形式表示。|

## 17.2 YieldedTokenInfos类型

```go
type YieldedTokenInfo struct {
	RemainingAmount         sdk.SysCoin `json:"remaining_amount"`
	StartBlockHeightToYield int64       `json:"start_block_height_to_yield"`
	AmountYieldedPerBlock   sdk.Dec     `json:"amount_yielded_per_block"`
}
```

**成员变量**
|成员变量名称|类型|描述|
|-----------|-----|---|
|RemainingAmount|sdk.SysCoin|表示剩余的可产出代币的数量，即还未被产出的代币数量。|
|StartBlockHeightToYield|int64|表示开始产出代币的区块高度，即在这个区块高度之后，用户开始产出代币。|
|AmountYieldedPerBlock|sdk.Dec|表示每个区块产出的代币数量，以 sdk.Dec 类型表示，说明了单位时间内产出代币的速率。|

这些成员变量描述了通过锁定其他代币而可以产出的代币的相关信息，包括剩余可产出数量、开始产出的区块高度以及每个区块产出的数量。这些信息对于了解代币产出的机制和速率非常重要，也为参与者提供了参考依据。








