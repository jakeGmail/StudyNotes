

# 1 调度器
在 `github.com/longg/nano` 框架中，**调度器（Scheduler）** 负责管理组件（Component）中 Handler 方法的执行方式，直接影响消息处理的并发模型和任务调度策略。它的核心作用是 **控制消息处理的顺序、并发性和资源分配**，适用于不同的业务场景（如游戏服务器、实时通信等）。

---

## **调度器在 `nano` 中的角色**
### **1. 基本作用**
- **任务调度**：决定如何执行组件中的 Handler 方法（如顺序执行、并行执行、定时触发等）。
- **并发控制**：管理协程（goroutine）的使用方式，避免资源竞争或过度消耗。
- **性能优化**：根据业务需求选择合适的调度策略（如高频消息用时间片，低延迟用轮询）。

---

### **2. 调度器类型**
`nano` 内置了多种调度器，通过 `WithSchedulerName(name)` 指定：

| 调度器名称       | 作用                                                                 | 适用场景                     |
|------------------|----------------------------------------------------------------------|-----------------------------|
| **`""`（默认）** | 使用全局调度器（协程池），每个 Handler 调用会分配一个协程。           | 通用场景，高并发但无序       |
| **`"rr"`**       | 轮询调度（Round-Robin），按顺序依次执行 Handler。                     | 需要严格顺序的任务           |
| **`"ts"`**       | 时间片调度（TimeSlice），基于时间轮算法，适合定时或周期性任务。       | 游戏帧同步、定时任务         |
| **自定义调度器** | 可自行实现 `Scheduler` 接口，完全控制执行逻辑。                      | 特殊需求（如优先级调度）     |

---

### **3. 调度器的工作流程**
1. **消息到达**：客户端发送请求到服务端，路由到对应的组件 Handler。
2. **调度器介入**：
   - 如果是 `""`（默认），Handler 会在一个新协程中立即执行。
   - 如果是 `"rr"`，Handler 会被放入队列，按顺序逐个执行。
   - 如果是 `"ts"`，Handler 会被分配到时间轮，按时间片触发。
3. **执行完成**：调度器确保 Handler 按预定策略运行，并返回结果。

---

### **4. 示例场景**
#### **场景 1：游戏房间（`"ts"` 调度器）**
```go
components.Register(
    NewRoomManager(),
    component.WithSchedulerName("ts"), // 时间片调度
)
```
- **作用**：保证所有玩家的操作按固定时间片（如 100ms 一帧）处理，避免快慢客户端不同步。
- **类比**：类似游戏引擎的 `FixedUpdate`。

#### **场景 2：聊天室（`"rr"` 调度器）**
```go
components.Register(
    NewChatService(),
    component.WithSchedulerName("rr"), // 轮询调度
)
```
- **作用**：确保消息严格按接收顺序处理（先到先执行），避免乱序。

#### **场景 3：高并发 API（默认调度器）**
```go
components.Register(
    NewAPIService(), // 默认调度器（协程池）
)
```
- **作用**：每个请求独立处理，最大化并发性能。

---

### **5. 如何选择调度器？**
| 需求                | 推荐调度器   |
|---------------------|-------------|
| 高并发，无需顺序     | 默认（`""`）|
| 严格顺序（如聊天）   | `"rr"`      |
| 定时/帧同步（如游戏）| `"ts"`      |
| 自定义逻辑          | 实现 `Scheduler` 接口 |

---

### **6. 自定义调度器**
如果需要特殊调度逻辑（如优先级队列），可以实现 `Scheduler` 接口：
```go
type MyScheduler struct{}

func (s *MyScheduler) Schedule(handler func()) {
    // 自定义调度逻辑（如延迟执行、优先级队列等）
    go handler() // 示例：直接异步执行
}

// 注册组件时使用自定义调度器
components.Register(
    NewMyComponent(),
    component.WithScheduler(&MyScheduler{}),
)
```

---

## **总结**
- **调度器是 `nano` 的“大脑”**，决定了消息如何被执行。
- **默认调度器**适合通用场景，`"rr"` 和 `"ts"` 分别解决顺序性和定时性问题。
- **游戏开发**中常用 `"ts"` 保证帧同步，`"rr"` 适合聊天或状态同步。
- 通过 `WithSchedulerName()` 或自定义 `Scheduler` 接口，可以灵活控制业务逻辑的执行方式。