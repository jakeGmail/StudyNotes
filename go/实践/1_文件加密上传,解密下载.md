
**流式加解密方法定义**
```go
package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
)

const CTRIVSize = 16

var (
	// 上传/下载文件的加解密的密钥
	aesKey []byte
)

func init() {
	aesKey, _ = hex.DecodeString("53a8c5d9e2f7b1a46c3b5d8e09f12a34")
}

// 生成加密流
func NewEncryptReaderCTR(src io.Reader) (io.Reader, error) {
	if len(aesKey) != 16 && len(aesKey) != 24 && len(aesKey) != 32 {
		return nil, fmt.Errorf("invalid AES key length: %d", len(aesKey))
	}

	iv := make([]byte, CTRIVSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, fmt.Errorf("generate iv: %w", err)
	}

	block, err := aes.NewCipher(aesKey)
	if err != nil {
		return nil, fmt.Errorf("new cipher: %w", err)
	}
	stream := cipher.NewCTR(block, iv)

	pr, pw := io.Pipe()

	go func() {
		defer func() {
			_ = pw.Close()
		}()

		// 1) 先写 IV
		if _, err := pw.Write(iv); err != nil {
			_ = pw.CloseWithError(fmt.Errorf("write iv: %w", err))
			return
		}

		// 2) 创建加密写入器并拷贝
		encWriter := &cipher.StreamWriter{S: stream, W: pw}
		if _, err := io.Copy(encWriter, src); err != nil {
			_ = pw.CloseWithError(fmt.Errorf("encrypt copy: %w", err))
			return
		}
	}()

	return pr, nil
}

// 生成解密流
func NewDecryptReaderCTR(r io.Reader) (io.Reader, error) {
	if len(aesKey) != 16 && len(aesKey) != 24 && len(aesKey) != 32 {
		return nil, fmt.Errorf("invalid AES key length: %d", len(aesKey))
	}

	iv := make([]byte, CTRIVSize)
	if _, err := io.ReadFull(r, iv); err != nil {
		return nil, fmt.Errorf("read iv: %w", err)
	}

	block, err := aes.NewCipher(aesKey)
	if err != nil {
		return nil, fmt.Errorf("new cipher: %w", err)
	}
	stream := cipher.NewCTR(block, iv)

	return &cipher.StreamReader{S: stream, R: r}, nil
}
```