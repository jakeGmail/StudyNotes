在服务端开发中，设计接口、代码架构需要仔细斟酌，避免后续频繁更改，增加不必要的工作。

# 1 接口设计

- 在分页查询时，常见的有两种分页查询方式，一种是通过page + size来进行分页，一种是通过lastItem + size分页
  - **page + size分页**: 每一页有size条内容, 查询第page页，这种查询方式适合数据不经常变动。或者数据会增量变动，对数据的排列顺序与增量顺序一致。
  - **lastItem + size分页**：每次查询size页，获取到一页的最后一个数据的lastItem, 下次查询再从lastItem开始查询。这种查询方式适合看数据经常变动，并且对数据的排序有要求。例如：在朋友圈点赞通知列表中，朋友的点赞通知需要根据点赞时间的倒序排列。如果我们使用page + size的方式进行查询，当用户在翻页期间，有新的点赞到来，新的点赞信息会插入队列的最前面，这时候后面的数据都会统一向后移动一位，这时候再次查询下一页时，会导致出现一个之前已经展示的重复数据。
  但如果使用<font color=red>lastItem + size分页</font>即使翻页期间有新的通知到来，也会只从lastItem开始往后查询，不会查询到重复的数据。
  以下的图解

  假设初始的点赞通知队列是<font color=green>[a, b, c, d, e, f, g]</font>从左到右按时间降序排列。假设size=3, 这样使用page+size的方式每页会查询3条记录。
  当page=1时查询到第一页内容<font color=#abcd33>[a, b, c]</font>。这时有一个新的点赞到达，这时点赞通知队列变为 <font color=green>[new, a, b, c, d, e, f, g]</font>, 然后查询下一页的内容(page=2, size=3), 在新的队列中就会查询到<font color=#abcd33>[c, d, e]</font>. 这里的c在page=1时已经出现过，就会出现查询重复的现象。

  我们再使用<font color=red>lastItem + size分页</font>方式查询推理一遍。初始的点赞通知队列是<font color=green>[a, b, c, d, e, f, g]</font>。 第一次查询(lastItem=0, size=3)，获取到结果<font color=#abcd33>[a, b, c]</font>， 下一次查询参数将是(lastItem=c, size=3), 这时同样有一个新的点赞通知到来，通知队列变为
  <font color=green>[new, a, b, c, d, e, f, g]</font>， 然后再查询下一页(lastItem=0, size=3)， 得到结果<font color=#abcd33>[d, e, f]</font>， 这时出现的查询结果不会重复。

- 在设计接口的时候，对于配置类的接口，可以设置一个预留字段(建议字符串类型)，方便后续增加功能

# 2 后端架构
- 对于后端架构为 网关 + 各类微服务的架构。 网关使用flatbuffers作为通信协议，内部微服务使用grpc作为通信协议。不需要在网关处将flatbuffer解析为结构化数据后再通过grpc转发给对应后端服务。而是直接将原始的flatbuffer数据透传给对应的服务，对应的服务自己解析返回将结果返回给网关。后端服务再解析flatbuffer数据做方法路由时，应该经理将handler方法放到map中，提高路由效率。

- 对于使用redis作为缓存中间件时，禁止使用 keys命令来查询key, 因为keys命令会遍历所有的key, 会导致redis阻塞，影响其他业务的进行。

- 如果使用了redis集群，需要注意不要在单次请求中跨节点访问key，会报错。如果希望单次操作访问多个key, 可以时间花括号重命名key, 让多个key落在同一个节点。例如 user:{node1}:123 、 user:{node1}:345、user:{node1}:678这三个key一定会落到同一个redis节点中。可以在同一次redis请求中访问这三个key

- 尽量将操作缓存操作的方法放到项目的同一个地方

- 对于需要管理媒体资源的需求（上传/下载）， 建议上传/下载都走自己写的代理接口，上传时将文件加密后存储到oss，下载时在进行解密后传输给客户端。上传接口不要将完整的访问路径返回给客户端，避免安全问题。

- 在设计数据库表的时候，对于有很多设置选项的存储，建议单个设置选项单独用一个字段存储，不要将所有设置选项存储到一个字段中。以是为了方便查询管理，二是后续迁移时方便，不会出现数据错误。
