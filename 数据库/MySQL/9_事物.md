# 1 数据库事物操作
MySQL 中的事务是指一组操作，这些操作要么都执行成功，要么全部回滚到之前的状态。MySQL 中的事务处理确保了多个 SQL 查询之间的原子性、一致性、隔离性和持久性。

常用到的 MySQL 事务操作有以下四个：

1. **开始事务**

在 MySQL 中，使用 `BEGIN`、`START TRANSACTION` 或者 `SET AUTOCOMMIT=0 ` 开启一个事务。

2. **提交事务**

使用 `COMMIT` 或者 `SET AUTOCOMMIT=1` 提交事务。

3. **回滚事务**

使用 `ROLLBACK` 回滚事务。

4. **设置事务隔离级别**

使用 `SET TRANSACTION ISOLATION LEVEL` 设置事务隔离级别。

MySQL 中的事务隔离级别通过控制数据的锁定和释放来实现。MySQL 提供了 4 种不同的隔离级别：

- **READ UNCOMMITTED**: 允许事务读取尚未提交的变更，最低级别，同时也发生在排他写锁和共享读锁之外。
READ UNCOMMITTED 是 MySQL 事务隔离级别中最低的一级，也称为“脏读”（Dirty Read）。在 READ UNCOMMITTED 级别中，事务可以读取其它事务未提交的数据，即允许一个事务获取另外一个事务未提交的修改，这种行为可能会导致数据不一致，如果一个事务修改了一条数据但还没有提交，另一个事务依旧可以“看到”这个未提交的值。</br>
READ UNCOMMITTED 级别最大的问题就是会导致脏读的情况。脏读指一个事务读取了另一个事务未提交的数据，而这个未提交的数据通常是不合法的、无效的，因此不应该被读取到。比如，在一个银行转账的场景中，一个事务正在“转账”操作，但还没有提交，这时另一个事务却“看到”了这个转账的操作，就会出现金额异常等问题。因此，为了保障数据的正确性和完整性，通常不建议使用 READ UNCOMMITTED 级别，除非确实需要不加限制地读取其它事务中的数据。</br>
值得注意的是，使用 READ UNCOMMITTED 级别会极大的影响数据的一致性，应该在特定的业务场景下谨慎使用，并确保业务逻辑的正确性和数据的完整性。一般来说，对于大多数业务场景，建议至少使用 READ COMMITTED 事务隔离级别。

- **READ COMMITTED**: READ COMMITTED 是 MySQL 事务隔离级别中比 READ UNCOMMITTED 更高一级的隔离级别。在 READ COMMITTED 级别中，事务只能读取已经提交的数据，每次读取的数据都是最新的，其他事务刚刚更新的同一记录是不可见的。</br>
READ COMMITTED 是最常用的事务隔离级别，在这个级别下，事务的并发量可以达到较高的水平，同时保证了数据的一致性和隔离性。</br>
但是，READ COMMITTED 级别也存在一些问题和局限性。其中最主要的问题之一是“不可重复读”（non-repeatable read）。不可重复读指在同一事务中，由于其它并发事务提交了更新操作导致同一行的数据不一致，因此多次读取同一行数据时，可能会获得不同的结果。</br>
例如，事务 A 在读取某一行数据时，该行数据可能被事务 B 修改并提交了更新操作，这导致事务 A 的两次读取结果不一致，从而导致数据的不一致性。</br>
为了解决这个问题，MySQL 提供了更高级别的事务隔离级别，如 REPEATABLE READ 和 SERIALIZABLE，它们提供了更高级别的锁定机制和数据一致性保障，但同时也带来了更高的成本和低效率的问题，需要根据具体的业务需求来综合考虑。

- **REPEATABLE READ**: REPEATABLE READ 是 MySQL 事务隔离级别中的一种，是在 READ COMMITTED 基础上增加了一些锁机制，保证了同一会话中所有查询的结果集是一致的。</br>
在 REPEATABLE READ 级别下，事务开始时会对所有查询的数据快照进行一致性读取，保证了后续的查询也采用同样的快照，所以在同一事务中多次读取同一行数据，结果也将保持一致。这个快照是通过获取共享锁来实现的。除非需要修改已经提交的记录，否则不会获得锁定。</br>
REPEATABLE READ 隔离级别在保证数据一致性的同时，并发性较高，因为读取操作不会产生锁，没有锁竞争，支持读写锁的多次读取共享。</br>
但是，使用 REPEATABLE READ 隔离级别也存在一些缺陷，最主要的问题是“幻读”（Phantom Read）。幻读是指当某个事务在读取某个数据时，另一个事务又执行了一条新的 INSERT 语句并提交，那么之前的事务再次读取同一个范围的数据时，会发现多了一条记录，这就是所谓的幻读。</br>
为了解决这个问题，MySQL 5.1 引入了新的特性，称为 “Next-Key Locking”，即在应用范围内使用更加严格的锁定策略，更好地避免幻读的问题。</br>
需要注意的是，每个隔离级别都有自己的优缺点和适用场景，应该根据具体的业务需求来选择合适的隔离级别。在使用 REPEATABLE READ 隔离级别时，需要注意控制事务的粒度，避免长时间占用锁资源，以及避免深度嵌套的事务，以保证系统性能和数据操作的正确性。
- **SERIALIZABLE**:  serializable 是 MySQL 事务隔离级别中最高的级别，具有最高的安全性。在 SERIALIZABLE 级别下，所有事务都以串行的方式执行，每个事务都会依次执行，不会出现任何并发冲突。SERIALIZABLE 级别保证了所有的事务都是按照序列执行的，并且所有更新和查询操作都会在事务提交后持久化到数据库，具有很高的一致性和可靠性。</br>
SERIALIZABLE 隔离级别采用的是“串行化”的机制，它通过限制并发性来保证数据一致性，每个事务必须等待并发事务执行完成后才能执行。在 SERIALIZABLE 隔离级别下，每个事务都会获取排他锁来防止其它事务对同一行数据的并发修改，同时也会获得共享锁以防止其它事务读取该数据。这种锁定机制极大地提高了数据的安全性和一致性。</br>
但是，因为 SERIALIZABLE 隔离级别下每个事务必须串行执行，所以会极大地影响数据库的并发性能，降低了整个系统的吞吐量。SERIALIZABLE 隔离级别一般只在绝对需要最高一致性和安全性的场景下使用，比如财务系统等非常重要的业务系统。</br>
需要注意的是，每个隔离级别都有自己的优缺点和适用场景，应该根据具体的业务需求来选择合适的隔离级别。在使用 SERIALIZABLE 隔离级别时，需要考虑到系统的性能和吞吐量与数据一致性和安全性之间的平衡，适当控制事务数量和处理的数据范围，以避免产生死锁等并发问题。

**示例：**
```sql
-- 设置事物隔离级别为REPEATABLE READ
set transaction isolation level READ COMMITTED
```