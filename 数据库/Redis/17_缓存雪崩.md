# **缓存雪崩原因**
1. 因为在较短时间内，缓存中的较多数据集中过期
2. 在此期间内收到大量访问这些过期数据的请求。
3. 因为数据过期导致redis未命中，redis向数据库中获取数据。
4. 而数据库同时接收大量请求 无法及时处理。从而使得Redis大量请求被积压，开始出现超时的现象。
5. 数据库流量激增，数据库崩溃
6. 重启后Redis仍然面对缓存中没有数据可用
7. Redis服务器资源被严重占用，Redis服务器崩溃
8. Redis集群呈现崩溃状态，集群瓦解
9. 应用服务器无法及时得到数据来响应请求，来自客户端的请求越来越多，应用服务器崩溃
10. 应用服务器、Redis、数据库全部重启效果都不理想

由此可知，导致缓存雪崩的重要原因是**短时间内大量key集中过期**


# 解决方案
**从业务上：**
1. 使用更多的页面静态化处理，降低页面上的数据大量从缓存上获取
2. 构建多级缓存架构。 Nginx缓存+Redis缓存+ehcache缓存
3. 检测Mysql严重耗时业务并对其优化。
   对数据库的瓶颈排查：例如超时查询，耗时较高事务等
4. 灾难预警机制：
   监控redis服务性能指标
   - CPU占用、CPU使用率
   - 内存容量
   - 查询平均响应时间
   - 线程数
5. 限流、降级
   短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问。

**从技术上：**
1. 使用LRU和LFU算法：
   LRU: 数据是最长时间没有被使用过的，按照LRU策略会被删除
   LFU：数据被使用的次数最少的将被删除
2. 数据有效期调整
   - 根据业务数据有效期进行分类错峰。A类90分钟，B类80分钟，C类70分钟
   - 过期时间使用固定时间+随机值的形式，稀释集中到期key的数量
3. 超热数据使用永久key
4. 定期维护（自动+人工）
   对即将过期的数据做访问分析，确认是否延迟，配合访问量统计，做热点数据延时
5. 加锁（慎用）--会造成拿不到锁的处于等待，因此不建议大量加锁